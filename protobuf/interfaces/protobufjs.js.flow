/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.8.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

/**
 * Provides common type definitions.
 * Can also be used to provide additional google types or your own custom types.
 * @param name Short name as in `google/protobuf/[name].proto` or full file name
 * @param json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition
 */
declare export function common(
  name: string,
  json: {
    [k: string]: any
  }
): void;
declare var common: typeof npm$namespace$common;

declare var npm$namespace$common: {
  get: typeof common$get
};

/**
 * Properties of a google.protobuf.Any message.
 */
declare interface common$IAny {
  typeUrl?: string;
  bytes?: Uint8Array;
}

/**
 * Properties of a google.protobuf.Duration message.
 */
declare interface common$IDuration {
  seconds?: number | Long;
  nanos?: number;
}

/**
 * Properties of a google.protobuf.Timestamp message.
 */
declare interface common$ITimestamp {
  seconds?: number | Long;
  nanos?: number;
}

/**
 * Properties of a google.protobuf.Empty message.
 */
declare interface common$IEmpty {}

/**
 * Properties of a google.protobuf.Struct message.
 */
declare interface common$IStruct {
  fields?: {
    [k: string]: common$IValue
  };
}

/**
 * Properties of a google.protobuf.Value message.
 */
declare interface common$IValue {
  kind?: string;
  nullValue?: 0;
  numberValue?: number;
  stringValue?: string;
  boolValue?: boolean;
  structValue?: common$IStruct;
  listValue?: common$IListValue;
}

/**
 * Properties of a google.protobuf.ListValue message.
 */
declare interface common$IListValue {
  values?: common$IValue[];
}

/**
 * Properties of a google.protobuf.DoubleValue message.
 */
declare interface common$IDoubleValue {
  value?: number;
}

/**
 * Properties of a google.protobuf.FloatValue message.
 */
declare interface common$IFloatValue {
  value?: number;
}

/**
 * Properties of a google.protobuf.Int64Value message.
 */
declare interface common$IInt64Value {
  value?: number | Long;
}

/**
 * Properties of a google.protobuf.UInt64Value message.
 */
declare interface common$IUInt64Value {
  value?: number | Long;
}

/**
 * Properties of a google.protobuf.Int32Value message.
 */
declare interface common$IInt32Value {
  value?: number;
}

/**
 * Properties of a google.protobuf.UInt32Value message.
 */
declare interface common$IUInt32Value {
  value?: number;
}

/**
 * Properties of a google.protobuf.BoolValue message.
 */
declare interface common$IBoolValue {
  value?: boolean;
}

/**
 * Properties of a google.protobuf.StringValue message.
 */
declare interface common$IStringValue {
  value?: string;
}

/**
 * Properties of a google.protobuf.BytesValue message.
 */
declare interface common$IBytesValue {
  value?: Uint8Array;
}

/**
 * Gets the root definition of the specified common proto file.
 *
 * Bundled definitions are:
 * - google/protobuf/any.proto
 * - google/protobuf/duration.proto
 * - google/protobuf/empty.proto
 * - google/protobuf/field_mask.proto
 * - google/protobuf/struct.proto
 * - google/protobuf/timestamp.proto
 * - google/protobuf/wrappers.proto
 * @param file Proto file name
 * @returns Root definition or `null` if not defined
 */
declare function common$get(file: string): INamespace | null;
declare var converter: typeof npm$namespace$converter;

declare var npm$namespace$converter: {
  fromObject: typeof converter$fromObject,
  toObject: typeof converter$toObject
};

/**
 * Generates a plain object to runtime message converter specific to the specified message type.
 * @param mtype Message type
 * @returns Codegen instance
 */
declare function converter$fromObject(mtype: Type): Codegen;

/**
 * Generates a runtime message to plain object converter specific to the specified message type.
 * @param mtype Message type
 * @returns Codegen instance
 */
declare function converter$toObject(mtype: Type): Codegen;

/**
 * Generates a decoder specific to the specified message type.
 * @param mtype Message type
 * @returns Codegen instance
 */
declare export function decoder(mtype: Type): Codegen;

/**
 * Generates an encoder specific to the specified message type.
 * @param mtype Message type
 * @returns Codegen instance
 */
declare export function encoder(mtype: Type): Codegen;

/**
 * Reflected enum.
 */
declare export class Enum mixins ReflectionObject {
  /**
   * Constructs a new enum instance.
   * @param name Unique name within its namespace
   * @param values Enum values as an object, by name
   * @param options Declared options
   * @param comment The comment for this enum
   * @param comments The value comments for this enum
   */
  constructor(
    name: string,
    values?: {
      [k: string]: number
    },
    options?: {
      [k: string]: any
    },
    comment?: string,
    comments?: {
      [k: string]: string
    }
  ): this;

  /**
   * Enum values by id.
   */
  valuesById: {
    [k: number]: string
  };

  /**
   * Enum values by name.
   */
  values: {
    [k: string]: number
  };

  /**
   * Enum comment text.
   */
  comment: string | null;

  /**
   * Value comment texts, if any.
   */
  comments: {
    [k: string]: string
  };

  /**
   * Reserved ranges, if any.
   */
  reserved: (number[] | string)[];

  /**
   * Constructs an enum from an enum descriptor.
   * @param name Enum name
   * @param json Enum descriptor
   * @returns Created enum
   * @throws {TypeError} If arguments are invalid
   */
  static fromJSON(name: string, json: IEnum): Enum;

  /**
   * Converts this enum to an enum descriptor.
   * @param toJSONOptions JSON conversion options
   * @returns Enum descriptor
   */
  toJSON(toJSONOptions?: IToJSONOptions): IEnum;

  /**
   * Adds a value to this enum.
   * @param name Value name
   * @param id Value id
   * @param comment Comment, if any
   * @returns `this`
   * @throws {TypeError} If arguments are invalid
   * @throws {Error} If there is already a value with this name or id
   */
  add(name: string, id: number, comment?: string): Enum;

  /**
   * Removes a value from this enum
   * @param name Value name
   * @returns `this`
   * @throws {TypeError} If arguments are invalid
   * @throws {Error} If `name` is not a name of this enum
   */
  remove(name: string): Enum;

  /**
   * Tests if the specified id is reserved.
   * @param id Id to test
   * @returns `true` if reserved, otherwise `false`
   */
  isReservedId(id: number): boolean;

  /**
   * Tests if the specified name is reserved.
   * @param name Name to test
   * @returns `true` if reserved, otherwise `false`
   */
  isReservedName(name: string): boolean;
}
/**
 * Enum descriptor.
 */
export interface IEnum {
  /**
   * Enum values
   */
  values: {
    [k: string]: number
  };

  /**
   * Enum options
   */
  options?: {
    [k: string]: any
  };
}
/**
 * Reflected message field.
 */
declare export class Field mixins FieldBase {
  /**
   * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
   * @param name Unique name within its namespace
   * @param id Unique id within its namespace
   * @param type Value type
   * @param rule Field rule
   * @param extend Extended type if different from parent
   * @param options Declared options
   */
  constructor(
    name: string,
    id: number,
    type: string,
    rule?:
      | string
      | {
          [k: string]: any
        },
    extend?:
      | string
      | {
          [k: string]: any
        },
    options?: {
      [k: string]: any
    }
  ): this;

  /**
   * Constructs a field from a field descriptor.
   * @param name Field name
   * @param json Field descriptor
   * @returns Created field
   * @throws {TypeError} If arguments are invalid
   */
  static fromJSON(name: string, json: IField): Field;

  /**
   * Determines whether this field is packed. Only relevant when repeated and working with proto2.
   */
  packed: boolean;

  /**
   * Field decorator (TypeScript).
   * @param fieldId Field id
   * @param fieldType Field type
   * @param fieldRule Field rule
   * @param defaultValue Default value
   * @returns Decorator function
   */
  static d<
    T:
      | number
      | number[]
      | Long
      | Long[]
      | string
      | string[]
      | boolean
      | boolean[]
      | Uint8Array
      | Uint8Array[]
      | Buffer
      | Buffer[]
  >(
    fieldId: number,
    fieldType:
      | "double"
      | "float"
      | "int32"
      | "uint32"
      | "sint32"
      | "fixed32"
      | "sfixed32"
      | "int64"
      | "uint64"
      | "sint64"
      | "fixed64"
      | "sfixed64"
      | "string"
      | "bool"
      | "bytes"
      | { [key: string]: any },
    fieldRule?: "optional" | "required" | "repeated",
    defaultValue?: T
  ): FieldDecorator;

  /**
   * Field decorator (TypeScript).
   * @param fieldId Field id
   * @param fieldType Field type
   * @param fieldRule Field rule
   * @returns Decorator function
   */
  static d<T: Message<T>>(
    fieldId: number,
    fieldType: Constructor<T> | string,
    fieldRule?: "optional" | "required" | "repeated"
  ): FieldDecorator;
}
/**
 * Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.
 */
declare export class FieldBase mixins ReflectionObject {
  /**
   * Not an actual constructor. Use {@link Field} instead.
   * @param name Unique name within its namespace
   * @param id Unique id within its namespace
   * @param type Value type
   * @param rule Field rule
   * @param extend Extended type if different from parent
   * @param options Declared options
   * @param comment Comment associated with this field
   */
  constructor(
    name: string,
    id: number,
    type: string,
    rule?:
      | string
      | {
          [k: string]: any
        },
    extend?:
      | string
      | {
          [k: string]: any
        },
    options?: {
      [k: string]: any
    },
    comment?: string
  ): this;

  /**
   * Field rule, if any.
   */
  rule: string;

  /**
   * Field type.
   */
  type: string;

  /**
   * Unique field id.
   */
  id: number;

  /**
   * Extended type if different from parent.
   */
  extend: string;

  /**
   * Whether this field is required.
   */
  required: boolean;

  /**
   * Whether this field is optional.
   */
  optional: boolean;

  /**
   * Whether this field is repeated.
   */
  repeated: boolean;

  /**
   * Whether this field is a map or not.
   */
  map: boolean;

  /**
   * Message this field belongs to.
   */
  message: Type | null;

  /**
   * OneOf this field belongs to, if any,
   */
  partOf: OneOf | null;

  /**
   * The field type's default value.
   */
  typeDefault: any;

  /**
   * The field's default value on prototypes.
   */
  defaultValue: any;

  /**
   * Whether this field's value should be treated as a long.
   */
  long: boolean;

  /**
   * Whether this field's value is a buffer.
   */
  bytes: boolean;

  /**
   * Resolved type if not a basic type.
   */
  resolvedType: Type | Enum | null;

  /**
   * Sister-field within the extended type if a declaring extension field.
   */
  extensionField: Field | null;

  /**
   * Sister-field within the declaring namespace if an extended field.
   */
  declaringField: Field | null;

  /**
   * Comment for this field.
   */
  comment: string | null;

  /**
   * Converts this field to a field descriptor.
   * @param toJSONOptions JSON conversion options
   * @returns Field descriptor
   */
  toJSON(toJSONOptions?: IToJSONOptions): IField;

  /**
   * Resolves this field's type references.
   * @returns `this`
   * @throws {Error} If any reference cannot be resolved
   */
  resolve(): Field;
}
/**
 * Field descriptor.
 */
export interface IField {
  /**
   * Field rule
   */
  rule?: string;

  /**
   * Field type
   */
  type: string;

  /**
   * Field id
   */
  id: number;

  /**
   * Field options
   */
  options?: {
    [k: string]: any
  };
}
/**
 * Extension field descriptor.
 */
export type IExtensionField = {
  /**
   * Extended type
   */
  extend: string
} & IField;

/**
 * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).
 * @param prototype Target prototype
 * @param fieldName Field name
 */
declare type FieldDecorator = (
  prototype: { [key: string]: any },
  fieldName: string
) => void;
/**
 * A node-style callback as used by {@link load} and {@link Root#load}.
 * @param error Error, if any, otherwise `null`
 * @param root Root, if there hasn't been an error
 */
declare type LoadCallback = (error: Error | null, root?: Root) => void;
/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @param filename One or multiple files to load
 * @param root Root namespace, defaults to create a new one if omitted.
 * @param callback Callback function
 * @see {@link Root#load}
 */
declare export function load(
  filename: string | string[],
  root: Root,
  callback: LoadCallback
): void;

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @param filename One or multiple files to load
 * @param callback Callback function
 * @see {@link Root#load}
 */
declare export function load(
  filename: string | string[],
  callback: LoadCallback
): void;

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.
 * @param filename One or multiple files to load
 * @param root Root namespace, defaults to create a new one if omitted.
 * @returns Promise
 * @see {@link Root#load}
 */
declare export function load(
  filename: string | string[],
  root?: Root
): Promise<Root>;

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).
 * @param filename One or multiple files to load
 * @param root Root namespace, defaults to create a new one if omitted.
 * @returns Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 * @see {@link Root#loadSync}
 */
declare export function loadSync(
  filename: string | string[],
  root?: Root
): Root;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 */
declare export var build: string;
/**
 * Reconfigures the library according to the environment.
 */
declare export function configure(): void;

/**
 * Reflected map field.
 */
declare export class MapField mixins FieldBase {
  /**
   * Constructs a new map field instance.
   * @param name Unique name within its namespace
   * @param id Unique id within its namespace
   * @param keyType Key type
   * @param type Value type
   * @param options Declared options
   * @param comment Comment associated with this field
   */
  constructor(
    name: string,
    id: number,
    keyType: string,
    type: string,
    options?: {
      [k: string]: any
    },
    comment?: string
  ): this;

  /**
   * Key type.
   */
  keyType: string;

  /**
   * Resolved key type if not a basic type.
   */
  resolvedKeyType: ReflectionObject | null;

  /**
   * Constructs a map field from a map field descriptor.
   * @param name Field name
   * @param json Map field descriptor
   * @returns Created map field
   * @throws {TypeError} If arguments are invalid
   */
  static fromJSON(name: string, json: IMapField): MapField;

  /**
   * Converts this map field to a map field descriptor.
   * @param toJSONOptions JSON conversion options
   * @returns Map field descriptor
   */
  toJSON(toJSONOptions?: IToJSONOptions): IMapField;

  /**
   * Map field decorator (TypeScript).
   * @param fieldId Field id
   * @param fieldKeyType Field key type
   * @param fieldValueType Field value type
   * @returns Decorator function
   */
  static d<
    T: {
      [key: string]:
        | number
        | Long
        | string
        | boolean
        | Uint8Array
        | Buffer
        | number[]
        | Message<{}>
    }
  >(
    fieldId: number,
    fieldKeyType:
      | "int32"
      | "uint32"
      | "sint32"
      | "fixed32"
      | "sfixed32"
      | "int64"
      | "uint64"
      | "sint64"
      | "fixed64"
      | "sfixed64"
      | "bool"
      | "string",
    fieldValueType:
      | "double"
      | "float"
      | "int32"
      | "uint32"
      | "sint32"
      | "fixed32"
      | "sfixed32"
      | "int64"
      | "uint64"
      | "sint64"
      | "fixed64"
      | "sfixed64"
      | "bool"
      | "string"
      | "bytes"
      | { [key: string]: any }
      | Constructor<{}>
  ): FieldDecorator;
}
/**
 * Map field descriptor.
 */
export type IMapField = {
  /**
   * Key type
   */
  keyType: string
} & IField;

/**
 * Extension map field descriptor.
 */
export type IExtensionMapField = {
  /**
   * Extended type
   */
  extend: string
} & IMapField;

/**
 * Abstract runtime message.
 */
declare export class Message<
  T: { [key: string]: any } = { [key: string]: any }
> {
  /**
   * Constructs a new message instance.
   * @param properties Properties to set
   */
  constructor(properties?: Properties<T>): this;

  /**
   * Reference to the reflected type.
   */
  static $type: Type;

  /**
   * Reference to the reflected type.
   */
  $type: Type;

  /**
   * Creates a new message of this type using the specified properties.
   * @param properties Properties to set
   * @returns Message instance
   */
  static create<T: Message<T>>(properties?: {
    [k: string]: any
  }): Message<T>;

  /**
   * Encodes a message of this type.
   * @param message Message to encode
   * @param writer Writer to use
   * @returns Writer
   */
  static encode<T: Message<T>>(
    message:
      | T
      | {
          [k: string]: any
        },
    writer?: Writer
  ): Writer;

  /**
   * Encodes a message of this type preceeded by its length as a varint.
   * @param message Message to encode
   * @param writer Writer to use
   * @returns Writer
   */
  static encodeDelimited<T: Message<T>>(
    message:
      | T
      | {
          [k: string]: any
        },
    writer?: Writer
  ): Writer;

  /**
   * Decodes a message of this type.
   * @param reader Reader or buffer to decode
   * @returns Decoded message
   */
  static decode<T: Message<T>>(reader: Reader | Uint8Array): T;

  /**
   * Decodes a message of this type preceeded by its length as a varint.
   * @param reader Reader or buffer to decode
   * @returns Decoded message
   */
  static decodeDelimited<T: Message<T>>(reader: Reader | Uint8Array): T;

  /**
   * Verifies a message of this type.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {
    [k: string]: any
  }): string | null;

  /**
   * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Message instance
   */
  static fromObject<T: Message<T>>(object: {
    [k: string]: any
  }): T;

  /**
   * Creates a plain object from a message of this type. Also converts values to other types if specified.
   * @param message Message instance
   * @param options Conversion options
   * @returns Plain object
   */
  static toObject<T: Message<T>>(
    message: T,
    options?: IConversionOptions
  ): {
    [k: string]: any
  };

  /**
   * Converts this message to JSON.
   * @returns JSON object
   */
  toJSON(): {
    [k: string]: any
  };
}
/**
 * Reflected service method.
 */
declare export class Method mixins ReflectionObject {
  /**
   * Constructs a new service method instance.
   * @param name Method name
   * @param type Method type, usually `"rpc"`
   * @param requestType Request message type
   * @param responseType Response message type
   * @param requestStream Whether the request is streamed
   * @param responseStream Whether the response is streamed
   * @param options Declared options
   * @param comment The comment for this method
   */
  constructor(
    name: string,
    type: string | void,
    requestType: string,
    responseType: string,
    requestStream?:
      | boolean
      | {
          [k: string]: any
        },
    responseStream?:
      | boolean
      | {
          [k: string]: any
        },
    options?: {
      [k: string]: any
    },
    comment?: string
  ): this;

  /**
   * Method type.
   */
  type: string;

  /**
   * Request type.
   */
  requestType: string;

  /**
   * Whether requests are streamed or not.
   */
  requestStream: boolean;

  /**
   * Response type.
   */
  responseType: string;

  /**
   * Whether responses are streamed or not.
   */
  responseStream: boolean;

  /**
   * Resolved request type.
   */
  resolvedRequestType: Type | null;

  /**
   * Resolved response type.
   */
  resolvedResponseType: Type | null;

  /**
   * Comment for this method
   */
  comment: string | null;

  /**
   * Constructs a method from a method descriptor.
   * @param name Method name
   * @param json Method descriptor
   * @returns Created method
   * @throws {TypeError} If arguments are invalid
   */
  static fromJSON(name: string, json: IMethod): Method;

  /**
   * Converts this method to a method descriptor.
   * @param toJSONOptions JSON conversion options
   * @returns Method descriptor
   */
  toJSON(toJSONOptions?: IToJSONOptions): IMethod;
}
/**
 * Method descriptor.
 */
export interface IMethod {
  /**
   * Method type
   */
  type?: string;

  /**
   * Request type
   */
  requestType: string;

  /**
   * Response type
   */
  responseType: string;

  /**
   * Whether requests are streamed
   */
  requestStream?: boolean;

  /**
   * Whether responses are streamed
   */
  responseStream?: boolean;

  /**
   * Method options
   */
  options?: {
    [k: string]: any
  };
}
/**
 * Reflected namespace.
 */
declare export class Namespace mixins NamespaceBase {
  /**
   * Constructs a new namespace instance.
   * @param name Namespace name
   * @param options Declared options
   */
  constructor(
    name: string,
    options?: {
      [k: string]: any
    }
  ): this;

  /**
   * Constructs a namespace from JSON.
   * @param name Namespace name
   * @param json JSON object
   * @returns Created namespace
   * @throws {TypeError} If arguments are invalid
   */
  static fromJSON(
    name: string,
    json: {
      [k: string]: any
    }
  ): Namespace;

  /**
   * Converts an array of reflection objects to JSON.
   * @param array Object array
   * @param toJSONOptions JSON conversion options
   * @returns JSON object or `undefined` when array is empty
   */
  static arrayToJSON(
    array: ReflectionObject[],
    toJSONOptions?: IToJSONOptions
  ): {
    [k: string]: any
  } | void;

  /**
   * Tests if the specified id is reserved.
   * @param reserved Array of reserved ranges and names
   * @param id Id to test
   * @returns `true` if reserved, otherwise `false`
   */
  static isReservedId(
    reserved: (number[] | string)[] | void,
    id: number
  ): boolean;

  /**
   * Tests if the specified name is reserved.
   * @param reserved Array of reserved ranges and names
   * @param name Name to test
   * @returns `true` if reserved, otherwise `false`
   */
  static isReservedName(
    reserved: (number[] | string)[] | void,
    name: string
  ): boolean;
}
/**
 * Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.
 */
declare export class NamespaceBase mixins ReflectionObject {
  /**
   * Nested objects by name.
   */
  nested: {
    [k: string]: ReflectionObject
  };

  /**
   * Nested objects of this namespace as an array for iteration.
   */
  nestedArray: ReflectionObject[];

  /**
   * Converts this namespace to a namespace descriptor.
   * @param toJSONOptions JSON conversion options
   * @returns Namespace descriptor
   */
  toJSON(toJSONOptions?: IToJSONOptions): INamespace;

  /**
   * Adds nested objects to this namespace from nested object descriptors.
   * @param nestedJson Any nested object descriptors
   * @returns `this`
   */
  addJSON(nestedJson: {
    [k: string]: AnyNestedObject
  }): Namespace;

  /**
   * Gets the nested object of the specified name.
   * @param name Nested object name
   * @returns The reflection object or `null` if it doesn't exist
   */
  get(name: string): ReflectionObject | null;

  /**
   * Gets the values of the nested {@link Enum|enum} of the specified name.
   * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.
   * @param name Nested enum name
   * @returns Enum values
   * @throws {Error} If there is no such enum
   */
  getEnum(
    name: string
  ): {
    [k: string]: number
  };

  /**
   * Adds a nested object to this namespace.
   * @param object Nested object to add
   * @returns `this`
   * @throws {TypeError} If arguments are invalid
   * @throws {Error} If there is already a nested object with this name
   */
  add(object: ReflectionObject): Namespace;

  /**
   * Removes a nested object from this namespace.
   * @param object Nested object to remove
   * @returns `this`
   * @throws {TypeError} If arguments are invalid
   * @throws {Error} If `object` is not a member of this namespace
   */
  remove(object: ReflectionObject): Namespace;

  /**
   * Defines additial namespaces within this one if not yet existing.
   * @param path Path to create
   * @param json Nested types to create from JSON
   * @returns Pointer to the last namespace created or `this` if path is empty
   */
  define(path: string | string[], json?: any): Namespace;

  /**
   * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.
   * @returns `this`
   */
  resolveAll(): Namespace;

  /**
   * Recursively looks up the reflection object matching the specified path in the scope of this namespace.
   * @param path Path to look up
   * @param filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.
   * @param parentAlreadyChecked If known, whether the parent has already been checked
   * @returns Looked up object or `null` if none could be found
   */
  lookup(
    path: string | string[],
    filterTypes: any | any[],
    parentAlreadyChecked?: boolean
  ): ReflectionObject | null;

  /**
   * Looks up the reflection object at the specified path, relative to this namespace.
   * @param path Path to look up
   * @param parentAlreadyChecked Whether the parent has already been checked
   * @returns Looked up object or `null` if none could be found
   */
  lookup(
    path: string | string[],
    parentAlreadyChecked?: boolean
  ): ReflectionObject | null;

  /**
   * Looks up the {@link Type|type} at the specified path, relative to this namespace.
   * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
   * @param path Path to look up
   * @returns Looked up type
   * @throws {Error} If `path` does not point to a type
   */
  lookupType(path: string | string[]): Type;

  /**
   * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.
   * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
   * @param path Path to look up
   * @returns Looked up enum
   * @throws {Error} If `path` does not point to an enum
   */
  lookupEnum(path: string | string[]): Enum;

  /**
   * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.
   * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
   * @param path Path to look up
   * @returns Looked up type or enum
   * @throws {Error} If `path` does not point to a type or enum
   */
  lookupTypeOrEnum(path: string | string[]): Type;

  /**
   * Looks up the {@link Service|service} at the specified path, relative to this namespace.
   * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
   * @param path Path to look up
   * @returns Looked up service
   * @throws {Error} If `path` does not point to a service
   */
  lookupService(path: string | string[]): rpc$Service;
}
/**
 * Namespace descriptor.
 */
export interface INamespace {
  /**
   * Namespace options
   */
  options?: {
    [k: string]: any
  };

  /**
   * Nested object descriptors
   */
  nested?: {
    [k: string]: AnyNestedObject
  };
}
/**
 * Any extension field descriptor.
 */
declare type AnyExtensionField = IExtensionField | IExtensionMapField;
/**
 * Any nested object descriptor.
 */
declare type AnyNestedObject =
  | IEnum
  | IType
  | IService
  | AnyExtensionField
  | INamespace;
/**
 * Base class of all reflection objects.
 */
declare export class ReflectionObject {
  /**
   * Options.
   */
  options: {
    [k: string]: any
  };

  /**
   * Unique name within its namespace.
   */
  name: string;

  /**
   * Parent namespace.
   */
  parent: Namespace | null;

  /**
   * Whether already resolved or not.
   */
  resolved: boolean;

  /**
   * Comment text, if any.
   */
  comment: string | null;

  /**
   * Defining file name.
   */
  filename: string | null;

  /**
   * Reference to the root namespace.
   */
  root: Root;

  /**
   * Full name including leading dot.
   */
  fullName: string;

  /**
   * Converts this reflection object to its descriptor representation.
   * @returns Descriptor
   */
  toJSON(): {
    [k: string]: any
  };

  /**
   * Called when this object is added to a parent.
   * @param parent Parent added to
   */
  onAdd(parent: ReflectionObject): void;

  /**
   * Called when this object is removed from a parent.
   * @param parent Parent removed from
   */
  onRemove(parent: ReflectionObject): void;

  /**
   * Resolves this objects type references.
   * @returns `this`
   */
  resolve(): ReflectionObject;

  /**
   * Gets an option value.
   * @param name Option name
   * @returns Option value or `undefined` if not set
   */
  getOption(name: string): any;

  /**
   * Sets an option.
   * @param name Option name
   * @param value Option value
   * @param ifNotSet Sets the option only if it isn't currently set
   * @returns `this`
   */
  setOption(name: string, value: any, ifNotSet?: boolean): ReflectionObject;

  /**
   * Sets multiple options.
   * @param options Options to set
   * @param ifNotSet Sets an option only if it isn't currently set
   * @returns `this`
   */
  setOptions(
    options: {
      [k: string]: any
    },
    ifNotSet?: boolean
  ): ReflectionObject;

  /**
   * Converts this instance to its string representation.
   * @returns Class name[, space, full name]
   */
  toString(): string;
}
/**
 * Reflected oneof.
 */
declare export class OneOf mixins ReflectionObject {
  /**
   * Constructs a new oneof instance.
   * @param name Oneof name
   * @param fieldNames Field names
   * @param options Declared options
   * @param comment Comment associated with this field
   */
  constructor(
    name: string,
    fieldNames?:
      | string[]
      | {
          [k: string]: any
        },
    options?: {
      [k: string]: any
    },
    comment?: string
  ): this;

  /**
   * Field names that belong to this oneof.
   */
  oneof: string[];

  /**
   * Fields that belong to this oneof as an array for iteration.
   */
  fieldsArray: Field[];

  /**
   * Comment for this field.
   */
  comment: string | null;

  /**
   * Constructs a oneof from a oneof descriptor.
   * @param name Oneof name
   * @param json Oneof descriptor
   * @returns Created oneof
   * @throws {TypeError} If arguments are invalid
   */
  static fromJSON(name: string, json: IOneOf): OneOf;

  /**
   * Converts this oneof to a oneof descriptor.
   * @param toJSONOptions JSON conversion options
   * @returns Oneof descriptor
   */
  toJSON(toJSONOptions?: IToJSONOptions): IOneOf;

  /**
   * Adds a field to this oneof and removes it from its current parent, if any.
   * @param field Field to add
   * @returns `this`
   */
  add(field: Field): OneOf;

  /**
   * Removes a field from this oneof and puts it back to the oneof's parent.
   * @param field Field to remove
   * @returns `this`
   */
  remove(field: Field): OneOf;

  /**
   * OneOf decorator (TypeScript).
   * @param fieldNames Field names
   * @returns Decorator function
   */
  static d<T: string>(...fieldNames: string[]): OneOfDecorator;
}
/**
 * Oneof descriptor.
 */
export interface IOneOf {
  /**
   * Oneof field names
   */
  oneof: string[];

  /**
   * Oneof options
   */
  options?: {
    [k: string]: any
  };
}
/**
 * Decorator function as returned by {@link OneOf.d} (TypeScript).
 * @param prototype Target prototype
 * @param oneofName OneOf name
 */
declare type OneOfDecorator = (
  prototype: { [key: string]: any },
  oneofName: string
) => void;
/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @param source Source contents
 * @param options Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns Parser result
 */
declare export function parse(
  source: string,
  options?: IParseOptions
): IParserResult;

/**
 * Result object returned from {@link parse}.
 */
export interface IParserResult {
  /**
   * Package name, if declared
   */
  package: string | void;

  /**
   * Imports, if any
   */
  imports: string[] | void;

  /**
   * Weak imports, if any
   */
  weakImports: string[] | void;

  /**
   * Syntax, if specified (either `"proto2"` or `"proto3"`)
   */
  syntax: string | void;

  /**
   * Populated root instance
   */
  root: Root;
}
/**
 * Options modifying the behavior of {@link parse}.
 */
export interface IParseOptions {
  /**
   * Keeps field casing instead of converting to camel case
   */
  keepCase?: boolean;

  /**
   * Recognize double-slash comments in addition to doc-block comments.
   */
  alternateCommentMode?: boolean;
}
/**
 * Options modifying the behavior of JSON serialization.
 */
export interface IToJSONOptions {
  /**
   * Serializes comments.
   */
  keepComments?: boolean;
}
/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @param source Source contents
 * @param root Root to populate
 * @param options Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns Parser result
 */
declare export function parse(
  source: string,
  root: Root,
  options?: IParseOptions
): IParserResult;

/**
 * Wire format reader using `Uint8Array` if available, otherwise `Array`.
 */
declare export class Reader {
  /**
   * Constructs a new reader instance using the specified buffer.
   * @param buffer Buffer to read from
   */
  constructor(buffer: Uint8Array): this;

  /**
   * Read buffer.
   */
  buf: Uint8Array;

  /**
   * Read buffer position.
   */
  pos: number;

  /**
   * Read buffer length.
   */
  len: number;

  /**
   * Creates a new reader using the specified buffer.
   * @param buffer Buffer to read from
   * @returns A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
   * @throws {Error} If `buffer` is not a valid buffer
   */
  static create(buffer: Uint8Array | Buffer): Reader | BufferReader;

  /**
   * Reads a varint as an unsigned 32 bit value.
   * @returns Value read
   */
  uint32(): number;

  /**
   * Reads a varint as a signed 32 bit value.
   * @returns Value read
   */
  int32(): number;

  /**
   * Reads a zig-zag encoded varint as a signed 32 bit value.
   * @returns Value read
   */
  sint32(): number;

  /**
   * Reads a varint as a signed 64 bit value.
   * @returns Value read
   */
  int64(): Long;

  /**
   * Reads a varint as an unsigned 64 bit value.
   * @returns Value read
   */
  uint64(): Long;

  /**
   * Reads a zig-zag encoded varint as a signed 64 bit value.
   * @returns Value read
   */
  sint64(): Long;

  /**
   * Reads a varint as a boolean.
   * @returns Value read
   */
  bool(): boolean;

  /**
   * Reads fixed 32 bits as an unsigned 32 bit integer.
   * @returns Value read
   */
  fixed32(): number;

  /**
   * Reads fixed 32 bits as a signed 32 bit integer.
   * @returns Value read
   */
  sfixed32(): number;

  /**
   * Reads fixed 64 bits.
   * @returns Value read
   */
  fixed64(): Long;

  /**
   * Reads zig-zag encoded fixed 64 bits.
   * @returns Value read
   */
  sfixed64(): Long;

  /**
   * Reads a float (32 bit) as a number.
   * @returns Value read
   */
  float(): number;

  /**
   * Reads a double (64 bit float) as a number.
   * @returns Value read
   */
  double(): number;

  /**
   * Reads a sequence of bytes preceeded by its length as a varint.
   * @returns Value read
   */
  bytes(): Uint8Array;

  /**
   * Reads a string preceeded by its byte length as a varint.
   * @returns Value read
   */
  string(): string;

  /**
   * Skips the specified number of bytes if specified, otherwise skips a varint.
   * @param length Length if known, otherwise a varint is assumed
   * @returns `this`
   */
  skip(length?: number): Reader;

  /**
   * Skips the next element of the specified wire type.
   * @param wireType Wire type received
   * @returns `this`
   */
  skipType(wireType: number): Reader;
}
/**
 * Wire format reader using node buffers.
 */
declare export class BufferReader mixins Reader {
  /**
   * Constructs a new buffer reader instance.
   * @param buffer Buffer to read from
   */
  constructor(buffer: Buffer): this;

  /**
   * Reads a sequence of bytes preceeded by its length as a varint.
   * @returns Value read
   */
  bytes(): Buffer;
}
/**
 * Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.
 */
declare export class Root mixins NamespaceBase {
  /**
   * Constructs a new root namespace instance.
   * @param options Top level options
   */
  constructor(options?: {
    [k: string]: any
  }): this;

  /**
   * Deferred extension fields.
   */
  deferred: Field[];

  /**
   * Resolved file names of loaded files.
   */
  files: string[];

  /**
   * Loads a namespace descriptor into a root namespace.
   * @param json Nameespace descriptor
   * @param root Root namespace, defaults to create a new one if omitted
   * @returns Root namespace
   */
  static fromJSON(json: INamespace, root?: Root): Root;

  /**
   * Resolves the path of an imported file, relative to the importing origin.
   * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
   * @param origin The file name of the importing file
   * @param target The file name being imported
   * @returns Resolved path to `target` or `null` to skip the file
   */
  resolvePath(origin: string, target: string): string | null;

  /**
   * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
   * @param filename Names of one or multiple files to load
   * @param options Parse options
   * @param callback Callback function
   */
  load(
    filename: string | string[],
    options: IParseOptions,
    callback: LoadCallback
  ): void;

  /**
   * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
   * @param filename Names of one or multiple files to load
   * @param callback Callback function
   */
  load(filename: string | string[], callback: LoadCallback): void;

  /**
   * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
   * @param filename Names of one or multiple files to load
   * @param options Parse options. Defaults to {@link parse.defaults} when omitted.
   * @returns Promise
   */
  load(filename: string | string[], options?: IParseOptions): Promise<Root>;

  /**
   * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
   * @param filename Names of one or multiple files to load
   * @param options Parse options. Defaults to {@link parse.defaults} when omitted.
   * @returns Root namespace
   * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
   */
  loadSync(filename: string | string[], options?: IParseOptions): Root;
}
/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 */
declare export var roots: {
  [k: string]: Root
};
declare var rpc: typeof npm$namespace$rpc;

declare var npm$namespace$rpc: {
  Service: typeof rpc$Service
};

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @param error Error, if any
 * @param response Response message
 */
declare type rpc$ServiceMethodCallback<TRes: Message<TRes>> = (
  error: Error | null,
  response?: TRes
) => void;

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @param request Request message or plain object
 * @param callback Node-style callback called with the error, if any, and the response message
 * @returns Promise if `callback` has been omitted, otherwise `undefined`
 */
declare type rpc$ServiceMethod<TReq: Message<TReq>, TRes: Message<TRes>> = (
  request: TReq | Properties<TReq>,
  callback?: rpc$ServiceMethodCallback<TRes>
) => Promise<Message<TRes>>;

/**
 * An RPC service as returned by {@link Service#create}.
 */
declare class rpc$Service mixins util$EventEmitter {
  /**
   * Constructs a new RPC service instance.
   * @param rpcImpl RPC implementation
   * @param requestDelimited Whether requests are length-delimited
   * @param responseDelimited Whether responses are length-delimited
   */
  constructor(
    rpcImpl: RPCImpl,
    requestDelimited?: boolean,
    responseDelimited?: boolean
  ): this;

  /**
   * RPC implementation. Becomes `null` once the service is ended.
   */
  rpcImpl: RPCImpl | null;

  /**
   * Whether requests are length-delimited.
   */
  requestDelimited: boolean;

  /**
   * Whether responses are length-delimited.
   */
  responseDelimited: boolean;

  /**
   * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
   * @param method Reflected or static method
   * @param requestCtor Request constructor
   * @param responseCtor Response constructor
   * @param request Request message or plain object
   * @param callback Service callback
   */
  rpcCall<TReq: Message<TReq>, TRes: Message<TRes>>(
    method: Method | rpc$ServiceMethod<TReq, TRes>,
    requestCtor: Constructor<TReq>,
    responseCtor: Constructor<TRes>,
    request: TReq | Properties<TReq>,
    callback: rpc$ServiceMethodCallback<TRes>
  ): void;

  /**
   * Ends this service and emits the `end` event.
   * @param endedByRPC Whether the service has been ended by the RPC implementation.
   * @returns `this`
   */
  end(endedByRPC?: boolean): rpc$Service;
}
/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @param method Reflected or static method being called
 * @param requestData Request data
 * @param callback Callback function
 */
declare type RPCImpl = (
  method: Method | rpc$ServiceMethod<Message<{}>, Message<{}>>,
  requestData: Uint8Array,
  callback: RPCImplCallback
) => void;
/**
 * Node-style callback as used by {@link RPCImpl}.
 * @param error Error, if any, otherwise `null`
 * @param response Response data or `null` to signal end of stream, if there hasn't been an error
 */
declare type RPCImplCallback = (
  error: Error | null,
  response?: Uint8Array | null
) => void;
/**
 * Reflected service.
 */
declare export class Service mixins NamespaceBase {
  /**
   * Constructs a new service instance.
   * @param name Service name
   * @param options Service options
   * @throws {TypeError} If arguments are invalid
   */
  constructor(
    name: string,
    options?: {
      [k: string]: any
    }
  ): this;

  /**
   * Service methods.
   */
  methods: {
    [k: string]: Method
  };

  /**
   * Constructs a service from a service descriptor.
   * @param name Service name
   * @param json Service descriptor
   * @returns Created service
   * @throws {TypeError} If arguments are invalid
   */
  static fromJSON(name: string, json: IService): rpc$Service;

  /**
   * Converts this service to a service descriptor.
   * @param toJSONOptions JSON conversion options
   * @returns Service descriptor
   */
  toJSON(toJSONOptions?: IToJSONOptions): IService;

  /**
   * Methods of this service as an array for iteration.
   */
  methodsArray: Method[];

  /**
   * Creates a runtime service using the specified rpc implementation.
   * @param rpcImpl RPC implementation
   * @param requestDelimited Whether requests are length-delimited
   * @param responseDelimited Whether responses are length-delimited
   * @returns RPC service. Useful where requests and/or responses are streamed.
   */
  create(
    rpcImpl: RPCImpl,
    requestDelimited?: boolean,
    responseDelimited?: boolean
  ): rpc$Service;
}
/**
 * Service descriptor.
 */
export type IService = {
  /**
   * Method descriptors
   */
  methods: {
    [k: string]: IMethod
  }
} & INamespace;

/**
 * Gets the next token and advances.
 * @returns Next token or `null` on eof
 */
declare type TokenizerHandleNext = () => string | null;
/**
 * Peeks for the next token.
 * @returns Next token or `null` on eof
 */
declare type TokenizerHandlePeek = () => string | null;
/**
 * Pushes a token back to the stack.
 * @param token Token
 */
declare type TokenizerHandlePush = (token: string) => void;
/**
 * Skips the next token.
 * @param expected Expected token
 * @param optional If optional
 * @returns Whether the token matched
 * @throws {Error} If the token didn't match and is not optional
 */
declare type TokenizerHandleSkip = (
  expected: string,
  optional?: boolean
) => boolean;
/**
 * Gets the comment on the previous line or, alternatively, the line comment on the specified line.
 * @param line Line number
 * @returns Comment text or `null` if none
 */
declare type TokenizerHandleCmnt = (line?: number) => string | null;
/**
 * Handle object returned from {@link tokenize}.
 */
export interface ITokenizerHandle {
  /**
   * Gets the next token and advances (`null` on eof)
   */
  next: TokenizerHandleNext;

  /**
   * Peeks for the next token (`null` on eof)
   */
  peek: TokenizerHandlePeek;

  /**
   * Pushes a token back to the stack
   */
  push: TokenizerHandlePush;

  /**
   * Skips a token, returns its presence and advances or, if non-optional and not present, throws
   */
  skip: TokenizerHandleSkip;

  /**
   * Gets the comment on the previous line or the line comment on the specified line, if any
   */
  cmnt: TokenizerHandleCmnt;

  /**
   * Current line number
   */
  line: number;
}
/**
 * Tokenizes the given .proto source and returns an object with useful utility functions.
 * @param source Source contents
 * @param alternateCommentMode Whether we should activate alternate comment parsing mode.
 * @returns Tokenizer handle
 */
declare export function tokenize(
  source: string,
  alternateCommentMode: boolean
): ITokenizerHandle;
declare var tokenize: typeof npm$namespace$tokenize;

declare var npm$namespace$tokenize: {
  unescape: typeof tokenize$unescape
};

/**
 * Unescapes a string.
 * @param str String to unescape
 * @returns Unescaped string
 */
declare function tokenize$unescape(str: string): string;

/**
 * Reflected message type.
 */
declare export class Type mixins NamespaceBase {
  /**
   * Constructs a new reflected message type instance.
   * @param name Message name
   * @param options Declared options
   */
  constructor(
    name: string,
    options?: {
      [k: string]: any
    }
  ): this;

  /**
   * Message fields.
   */
  fields: {
    [k: string]: Field
  };

  /**
   * Oneofs declared within this namespace, if any.
   */
  oneofs: {
    [k: string]: OneOf
  };

  /**
   * Extension ranges, if any.
   */
  extensions: number[][];

  /**
   * Reserved ranges, if any.
   */
  reserved: (number[] | string)[];

  /**
   * Message fields by id.
   */
  fieldsById: {
    [k: number]: Field
  };

  /**
   * Fields of this message as an array for iteration.
   */
  fieldsArray: Field[];

  /**
   * Oneofs of this message as an array for iteration.
   */
  oneofsArray: OneOf[];

  /**
   * The registered constructor, if any registered, otherwise a generic constructor.
   * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
   */
  ctor: Constructor<{}>;

  /**
   * Generates a constructor function for the specified type.
   * @param mtype Message type
   * @returns Codegen instance
   */
  static generateConstructor(mtype: Type): Codegen;

  /**
   * Creates a message type from a message type descriptor.
   * @param name Message name
   * @param json Message type descriptor
   * @returns Created message type
   */
  static fromJSON(name: string, json: IType): Type;

  /**
   * Converts this message type to a message type descriptor.
   * @param toJSONOptions JSON conversion options
   * @returns Message type descriptor
   */
  toJSON(toJSONOptions?: IToJSONOptions): IType;

  /**
   * Adds a nested object to this type.
   * @param object Nested object to add
   * @returns `this`
   * @throws {TypeError} If arguments are invalid
   * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id
   */
  add(object: ReflectionObject): Type;

  /**
   * Removes a nested object from this type.
   * @param object Nested object to remove
   * @returns `this`
   * @throws {TypeError} If arguments are invalid
   * @throws {Error} If `object` is not a member of this type
   */
  remove(object: ReflectionObject): Type;

  /**
   * Tests if the specified id is reserved.
   * @param id Id to test
   * @returns `true` if reserved, otherwise `false`
   */
  isReservedId(id: number): boolean;

  /**
   * Tests if the specified name is reserved.
   * @param name Name to test
   * @returns `true` if reserved, otherwise `false`
   */
  isReservedName(name: string): boolean;

  /**
   * Creates a new message of this type using the specified properties.
   * @param properties Properties to set
   * @returns Message instance
   */
  create(properties?: {
    [k: string]: any
  }): Message<{}>;

  /**
   * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.
   * @returns `this`
   */
  setup(): Type;

  /**
   * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.
   * @param message Message instance or plain object
   * @param writer Writer to encode to
   * @returns writer
   */
  encode(
    message:
      | Message<{}>
      | {
          [k: string]: any
        },
    writer?: Writer
  ): Writer;

  /**
   * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.
   * @param message Message instance or plain object
   * @param writer Writer to encode to
   * @returns writer
   */
  encodeDelimited(
    message:
      | Message<{}>
      | {
          [k: string]: any
        },
    writer?: Writer
  ): Writer;

  /**
   * Decodes a message of this type.
   * @param reader Reader or buffer to decode from
   * @param length Length of the message, if known beforehand
   * @returns Decoded message
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {util.ProtocolError<{}>} If required fields are missing
   */
  decode(reader: Reader | Uint8Array, length?: number): Message<{}>;

  /**
   * Decodes a message of this type preceeded by its byte length as a varint.
   * @param reader Reader or buffer to decode from
   * @returns Decoded message
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {util.ProtocolError} If required fields are missing
   */
  decodeDelimited(reader: Reader | Uint8Array): Message<{}>;

  /**
   * Verifies that field values are valid and that required fields are present.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  verify(message: {
    [k: string]: any
  }): null | string;

  /**
   * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
   * @param object Plain object to convert
   * @returns Message instance
   */
  fromObject(object: {
    [k: string]: any
  }): Message<{}>;

  /**
   * Creates a plain object from a message of this type. Also converts values to other types if specified.
   * @param message Message instance
   * @param options Conversion options
   * @returns Plain object
   */
  toObject(
    message: Message<{}>,
    options?: IConversionOptions
  ): {
    [k: string]: any
  };

  /**
   * Type decorator (TypeScript).
   * @param typeName Type name, defaults to the constructor's name
   * @returns Decorator function
   */
  static d<T: Message<T>>(typeName?: string): TypeDecorator<T>;
}
/**
 * Message type descriptor.
 */
export type IType = {
  /**
   * Oneof descriptors
   */
  oneofs?: {
    [k: string]: IOneOf
  },

  /**
   * Field descriptors
   */
  fields: {
    [k: string]: IField
  },

  /**
   * Extension ranges
   */
  extensions?: number[][],

  /**
   * Reserved ranges
   */
  reserved?: number[][],

  /**
   * Whether a legacy group or not
   */
  group?: boolean
} & INamespace;

/**
 * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.
 */
export interface IConversionOptions {
  /**
   * Long conversion type.
   * Valid values are `String` and `Number` (the global types).
   * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.
   */
  longs?: Function;

  /**
   * Enum value conversion type.
   * Only valid value is `String` (the global type).
   * Defaults to copy the present value, which is the numeric id.
   */
  enums?: Function;

  /**
   * Bytes value conversion type.
   * Valid values are `Array` and (a base64 encoded) `String` (the global types).
   * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
   */
  bytes?: Function;

  /**
   * Also sets default values on the resulting object
   */
  defaults?: boolean;

  /**
   * Sets empty arrays for missing repeated fields even if `defaults=false`
   */
  arrays?: boolean;

  /**
   * Sets empty objects for missing map fields even if `defaults=false`
   */
  objects?: boolean;

  /**
   * Includes virtual oneof properties set to the present field's name, if any
   */
  oneofs?: boolean;

  /**
   * Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings
   */
  json?: boolean;
}
/**
 * Decorator function as returned by {@link Type.d} (TypeScript).
 * @param target Target constructor
 */
declare type TypeDecorator<T: Message<T>> = (target: Constructor<T>) => void;
declare var types: typeof npm$namespace$types;

declare var npm$namespace$types: {
  basic: typeof types$basic,
  defaults: typeof types$defaults,
  long: typeof types$long,
  mapKey: typeof types$mapKey,
  packed: typeof types$packed
};

/**
 * Basic type wire types.
 */
declare var types$basic: {
  double: number,
  float: number,
  int32: number,
  uint32: number,
  sint32: number,
  fixed32: number,
  sfixed32: number,
  int64: number,
  uint64: number,
  sint64: number,
  fixed64: number,
  sfixed64: number,
  bool: number,
  string: number,
  bytes: number
};

/**
 * Basic type defaults.
 */
declare var types$defaults: {
  double: number,
  float: number,
  int32: number,
  uint32: number,
  sint32: number,
  fixed32: number,
  sfixed32: number,
  int64: number,
  uint64: number,
  sint64: number,
  fixed64: number,
  sfixed64: number,
  bool: boolean,
  string: string,
  bytes: number[],
  message: null
};

/**
 * Basic long type wire types.
 */
declare var types$long: {
  int64: number,
  uint64: number,
  sint64: number,
  fixed64: number,
  sfixed64: number
};

/**
 * Allowed types for map keys with their associated wire type.
 */
declare var types$mapKey: {
  int32: number,
  uint32: number,
  sint32: number,
  fixed32: number,
  sfixed32: number,
  int64: number,
  uint64: number,
  sint64: number,
  fixed64: number,
  sfixed64: number,
  bool: number,
  string: number
};

/**
 * Allowed types for packed repeated fields with their associated wire type.
 */
declare var types$packed: {
  double: number,
  float: number,
  int32: number,
  uint32: number,
  sint32: number,
  fixed32: number,
  sfixed32: number,
  int64: number,
  uint64: number,
  sint64: number,
  fixed64: number,
  sfixed64: number,
  bool: number
};
/**
 * Constructor type.
 */
export type Constructor<T> = {
  new(...params: any[]): T,
  prototype: T
} & Function;

/**
 * Properties type.
 */
declare type Properties<T> = $ObjMapi<T, <P>(P) => $ElementType<T, P>>;
/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 */
export type Buffer = {} & Uint8Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 */
export interface Long {
  /**
   * Low bits
   */
  low: number;

  /**
   * High bits
   */
  high: number;

  /**
   * Whether unsigned or not
   */
  unsigned: boolean;
}
/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @returns Set field name, if any
 */
declare type OneOfGetter = () => string | void;
/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @param value Field name
 */
declare type OneOfSetter = (value: string | void) => void;
declare var util: typeof npm$namespace$util;

declare var npm$namespace$util: {
  isInteger: typeof util$isInteger,
  isString: typeof util$isString,
  isObject: typeof util$isObject,
  isset: typeof util$isset,
  isSet: typeof util$isSet,
  newBuffer: typeof util$newBuffer,
  longToHash: typeof util$longToHash,
  longFromHash: typeof util$longFromHash,
  merge: typeof util$merge,
  lcFirst: typeof util$lcFirst,
  newError: typeof util$newError,
  oneOfGetter: typeof util$oneOfGetter,
  oneOfSetter: typeof util$oneOfSetter,
  toArray: typeof util$toArray,
  toObject: typeof util$toObject,
  isReserved: typeof util$isReserved,
  safeProp: typeof util$safeProp,
  ucFirst: typeof util$ucFirst,
  camelCase: typeof util$camelCase,
  compareFieldsById: typeof util$compareFieldsById,
  decorateType: typeof util$decorateType,
  decorateEnum: typeof util$decorateEnum,
  asPromise: typeof util$asPromise,
  codegen: typeof util$codegen,
  fetch: typeof util$fetch,
  inquire: typeof util$inquire,
  pool: typeof util$pool,
  emptyArray: typeof util$emptyArray,
  emptyObject: typeof util$emptyObject,
  isNode: typeof util$isNode,
  Buffer: typeof util$Buffer,
  Array: typeof util$Array,
  Long: typeof util$Long,
  key2Re: typeof util$key2Re,
  key32Re: typeof util$key32Re,
  key64Re: typeof util$key64Re,
  toJSONOptions: typeof util$toJSONOptions,
  fs: typeof util$fs,
  decorateRoot: typeof util$decorateRoot,

  LongBits: typeof util$LongBits,
  ProtocolError: typeof util$ProtocolError,
  EventEmitter: typeof util$EventEmitter,
  base64: typeof npm$namespace$util$base64,
  codegen: typeof npm$namespace$util$codegen,
  float: typeof npm$namespace$util$float,
  path: typeof npm$namespace$util$path,
  utf8: typeof npm$namespace$util$utf8
};

/**
 * Helper class for working with the low and high bits of a 64 bit value.
 */
declare class util$LongBits {
  /**
   * Constructs new long bits.
   * @param lo Low 32 bits, unsigned
   * @param hi High 32 bits, unsigned
   */
  constructor(lo: number, hi: number): this;

  /**
   * Low bits.
   */
  lo: number;

  /**
   * High bits.
   */
  hi: number;

  /**
   * Zero bits.
   */
  static zero: util$LongBits;

  /**
   * Zero hash.
   */
  static zeroHash: string;

  /**
   * Constructs new long bits from the specified number.
   * @param value Value
   * @returns Instance
   */
  static fromNumber(value: number): util$LongBits;

  /**
   * Constructs new long bits from a number, long or string.
   * @param value Value
   * @returns Instance
   */
  static from(value: Long | number | string): util$LongBits;

  /**
   * Converts this long bits to a possibly unsafe JavaScript number.
   * @param unsigned Whether unsigned or not
   * @returns Possibly unsafe number
   */
  toNumber(unsigned?: boolean): number;

  /**
   * Converts this long bits to a long.
   * @param unsigned Whether unsigned or not
   * @returns Long
   */
  toLong(unsigned?: boolean): Long;

  /**
   * Constructs new long bits from the specified 8 characters long hash.
   * @param hash Hash
   * @returns Bits
   */
  static fromHash(hash: string): util$LongBits;

  /**
   * Converts this long bits to a 8 characters long hash.
   * @returns Hash
   */
  toHash(): string;

  /**
   * Zig-zag encodes this long bits.
   * @returns `this`
   */
  zzEncode(): util$LongBits;

  /**
   * Zig-zag decodes this long bits.
   * @returns `this`
   */
  zzDecode(): util$LongBits;

  /**
   * Calculates the length of this longbits when encoded as a varint.
   * @returns Length
   */
  length(): number;
}

/**
 * An immuable empty array.
 */
declare var util$emptyArray: any[];

/**
 * An immutable empty object.
 */
declare var util$emptyObject: { [key: string]: any };

/**
 * Whether running within node or not.
 */
declare var util$isNode: boolean;

/**
 * Tests if the specified value is an integer.
 * @param value Value to test
 * @returns `true` if the value is an integer
 */
declare function util$isInteger(value: any): boolean;

/**
 * Tests if the specified value is a string.
 * @param value Value to test
 * @returns `true` if the value is a string
 */
declare function util$isString(value: any): boolean;

/**
 * Tests if the specified value is a non-null object.
 * @param value Value to test
 * @returns `true` if the value is a non-null object
 */
declare function util$isObject(value: any): boolean;

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @param obj Plain object or message instance
 * @param prop Property name
 * @returns `true` if considered to be present, otherwise `false`
 */
declare function util$isset(obj: { [key: string]: any }, prop: string): boolean;

/**
 * Checks if a property on a message is considered to be present.
 * @param obj Plain object or message instance
 * @param prop Property name
 * @returns `true` if considered to be present, otherwise `false`
 */
declare function util$isSet(obj: { [key: string]: any }, prop: string): boolean;

/**
 * Node's Buffer class if available.
 */
declare var util$Buffer: Constructor<util$Buffer>;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param sizeOrArray Buffer size or number array
 * @returns Buffer
 */
declare function util$newBuffer(
  sizeOrArray?: number | number[]
): Uint8Array | util$Buffer;

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 */
declare var util$Array: Constructor<Uint8Array>;

/**
 * Long.js's Long class if available.
 */
declare var util$Long: Constructor<util$Long>;

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 */
declare var util$key2Re: RegExp;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 */
declare var util$key32Re: RegExp;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 */
declare var util$key64Re: RegExp;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param value Value to convert
 * @returns Hash
 */
declare function util$longToHash(value: util$Long | number): string;

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param hash Hash
 * @param unsigned Whether unsigned or not
 * @returns Original value
 */
declare function util$longFromHash(
  hash: string,
  unsigned?: boolean
): util$Long | number;

/**
 * Merges the properties of the source object into the destination object.
 * @param dst Destination object
 * @param src Source object
 * @param ifNotSet Merges only if the key is not already set
 * @returns Destination object
 */
declare function util$merge(
  dst: {
    [k: string]: any
  },
  src: {
    [k: string]: any
  },
  ifNotSet?: boolean
): {
  [k: string]: any
};

/**
 * Converts the first character of a string to lower case.
 * @param str String to convert
 * @returns Converted string
 */
declare function util$lcFirst(str: string): string;

/**
 * Creates a custom error constructor.
 * @param name Error name
 * @returns Custom error constructor
 */
declare function util$newError(name: string): Constructor<Error>;

/**
 * Error subclass indicating a protocol specifc error.
 */
declare class util$ProtocolError<T: Message<T>> mixins Error {
  /**
   * Constructs a new protocol error.
   * @param message Error message
   * @param properties Additional properties
   */
  constructor(
    message: string,
    properties?: {
      [k: string]: any
    }
  ): this;

  /**
   * So far decoded message instance.
   */
  instance: Message<T>;
}

/**
 * Builds a getter for a oneof's present field name.
 * @param fieldNames Field names
 * @returns Unbound getter
 */
declare function util$oneOfGetter(fieldNames: string[]): OneOfGetter;

/**
 * Builds a setter for a oneof's present field name.
 * @param fieldNames Field names
 * @returns Unbound setter
 */
declare function util$oneOfSetter(fieldNames: string[]): OneOfSetter;

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
declare var util$toJSONOptions: IConversionOptions;

/**
 * Node's fs module if available.
 */
declare var util$fs: {
  [k: string]: any
};

/**
 * Converts an object's values to an array.
 * @param object Object to convert
 * @returns Converted array
 */
declare function util$toArray(object: {
  [k: string]: any
}): any[];

/**
 * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
 * @param array Array to convert
 * @returns Converted object
 */
declare function util$toObject(
  array: any[]
): {
  [k: string]: any
};

/**
 * Tests whether the specified name is a reserved word in JS.
 * @param name Name to test
 * @returns `true` if reserved, otherwise `false`
 */
declare function util$isReserved(name: string): boolean;

/**
 * Returns a safe property accessor for the specified property name.
 * @param prop Property name
 * @returns Safe accessor
 */
declare function util$safeProp(prop: string): string;

/**
 * Converts the first character of a string to upper case.
 * @param str String to convert
 * @returns Converted string
 */
declare function util$ucFirst(str: string): string;

/**
 * Converts a string to camel case.
 * @param str String to convert
 * @returns Converted string
 */
declare function util$camelCase(str: string): string;

/**
 * Compares reflected fields by id.
 * @param a First field
 * @param b Second field
 * @returns Comparison value
 */
declare function util$compareFieldsById(a: Field, b: Field): number;

/**
 * Decorator helper for types (TypeScript).
 * @param ctor Constructor function
 * @param typeName Type name, defaults to the constructor's name
 * @returns Reflected type
 */
declare function util$decorateType<T: Message<T>>(
  ctor: Constructor<T>,
  typeName?: string
): Type;

/**
 * Decorator helper for enums (TypeScript).
 * @param object Enum object
 * @returns Reflected enum
 */
declare function util$decorateEnum(object: { [key: string]: any }): Enum;

/**
 * Decorator root (TypeScript).
 */
declare var util$decorateRoot: Root;

/**
 * Returns a promise from a node-style callback function.
 * @param fn Function to call
 * @param ctx Function context
 * @param params Function arguments
 * @returns Promisified function
 */
declare function util$asPromise(
  fn: asPromiseCallback,
  ctx: any,
  ...params: any[]
): Promise<any>;

declare var npm$namespace$util$base64: {
  length: typeof util$base64$length,
  encode: typeof util$base64$encode,
  decode: typeof util$base64$decode,
  test: typeof util$base64$test
};

/**
 * Calculates the byte length of a base64 encoded string.
 * @param string Base64 encoded string
 * @returns Byte length
 */
declare function util$base64$length(string: string): number;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param buffer Source buffer
 * @param start Source start
 * @param end Source end
 * @returns Base64 encoded string
 */
declare function util$base64$encode(
  buffer: Uint8Array,
  start: number,
  end: number
): string;

/**
 * Decodes a base64 encoded string to a buffer.
 * @param string Source string
 * @param buffer Destination buffer
 * @param offset Destination offset
 * @returns Number of bytes written
 * @throws {Error} If encoding is invalid
 */
declare function util$base64$decode(
  string: string,
  buffer: Uint8Array,
  offset: number
): number;

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param string String to test
 * @returns `true` if probably base64 encoded, otherwise false
 */
declare function util$base64$test(string: string): boolean;

/**
 * Begins generating a function.
 * @param functionParams Function parameter names
 * @param functionName Function name if not anonymous
 * @returns Appender that appends code to the function's body
 */
declare function util$codegen(
  functionParams: string[],
  functionName?: string
): Codegen;

declare var npm$namespace$util$codegen: {
  verbose: typeof util$codegen$verbose
};

/**
 * When set to `true`, codegen will log generated code to console. Useful for debugging.
 */
declare var util$codegen$verbose: boolean;

/**
 * Begins generating a function.
 * @param functionName Function name if not anonymous
 * @returns Appender that appends code to the function's body
 */
declare function util$codegen(functionName?: string): Codegen;

/**
 * A minimal event emitter.
 */
declare class util$EventEmitter {
  /**
   * Constructs a new event emitter instance.
   */
  constructor(): this;

  /**
   * Registers an event listener.
   * @param evt Event name
   * @param fn Listener
   * @param ctx Listener context
   * @returns `this`
   */
  on(evt: string, fn: EventEmitterListener, ctx?: any): this;

  /**
   * Removes an event listener or any matching listeners if arguments are omitted.
   * @param evt Event name. Removes all listeners if omitted.
   * @param fn Listener to remove. Removes all listeners of `evt` if omitted.
   * @returns `this`
   */
  off(evt?: string, fn?: EventEmitterListener): this;

  /**
   * Emits an event by calling its listeners with the specified arguments.
   * @param evt Event name
   * @param args Arguments
   * @returns `this`
   */
  emit(evt: string, ...args: any[]): this;
}

declare var npm$namespace$util$float: {
  writeFloatLE: typeof util$float$writeFloatLE,
  writeFloatBE: typeof util$float$writeFloatBE,
  readFloatLE: typeof util$float$readFloatLE,
  readFloatBE: typeof util$float$readFloatBE,
  writeDoubleLE: typeof util$float$writeDoubleLE,
  writeDoubleBE: typeof util$float$writeDoubleBE,
  readDoubleLE: typeof util$float$readDoubleLE,
  readDoubleBE: typeof util$float$readDoubleBE
};

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @param val Value to write
 * @param buf Target buffer
 * @param pos Target buffer offset
 */
declare function util$float$writeFloatLE(
  val: number,
  buf: Uint8Array,
  pos: number
): void;

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @param val Value to write
 * @param buf Target buffer
 * @param pos Target buffer offset
 */
declare function util$float$writeFloatBE(
  val: number,
  buf: Uint8Array,
  pos: number
): void;

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @param buf Source buffer
 * @param pos Source buffer offset
 * @returns Value read
 */
declare function util$float$readFloatLE(buf: Uint8Array, pos: number): number;

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @param buf Source buffer
 * @param pos Source buffer offset
 * @returns Value read
 */
declare function util$float$readFloatBE(buf: Uint8Array, pos: number): number;

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @param val Value to write
 * @param buf Target buffer
 * @param pos Target buffer offset
 */
declare function util$float$writeDoubleLE(
  val: number,
  buf: Uint8Array,
  pos: number
): void;

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @param val Value to write
 * @param buf Target buffer
 * @param pos Target buffer offset
 */
declare function util$float$writeDoubleBE(
  val: number,
  buf: Uint8Array,
  pos: number
): void;

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @param buf Source buffer
 * @param pos Source buffer offset
 * @returns Value read
 */
declare function util$float$readDoubleLE(buf: Uint8Array, pos: number): number;

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @param buf Source buffer
 * @param pos Source buffer offset
 * @returns Value read
 */
declare function util$float$readDoubleBE(buf: Uint8Array, pos: number): number;

/**
 * Fetches the contents of a file.
 * @param filename File path or url
 * @param options Fetch options
 * @param callback Callback function
 */
declare function util$fetch(
  filename: string,
  options: IFetchOptions,
  callback: FetchCallback
): void;

/**
 * Fetches the contents of a file.
 * @param path File path or url
 * @param callback Callback function
 */
declare function util$fetch(path: string, callback: FetchCallback): void;

/**
 * Fetches the contents of a file.
 * @param path File path or url
 * @param options Fetch options
 * @returns Promise
 */
declare function util$fetch(
  path: string,
  options?: IFetchOptions
): Promise<string | Uint8Array>;

/**
 * Requires a module only if available.
 * @param moduleName Module to require
 * @returns Required module if available and not empty, otherwise `null`
 */
declare function util$inquire(moduleName: string): { [key: string]: any };

declare var npm$namespace$util$path: {
  isAbsolute: typeof util$path$isAbsolute,
  normalize: typeof util$path$normalize,
  resolve: typeof util$path$resolve
};

/**
 * Tests if the specified path is absolute.
 * @param path Path to test
 * @returns `true` if path is absolute
 */
declare function util$path$isAbsolute(path: string): boolean;

/**
 * Normalizes the specified path.
 * @param path Path to normalize
 * @returns Normalized path
 */
declare function util$path$normalize(path: string): string;

/**
 * Resolves the specified include path against the specified origin path.
 * @param originPath Path to the origin file
 * @param includePath Include path relative to origin path
 * @param alreadyNormalized `true` if both paths are already known to be normalized
 * @returns Path to the include file
 */
declare function util$path$resolve(
  originPath: string,
  includePath: string,
  alreadyNormalized?: boolean
): string;

/**
 * A general purpose buffer pool.
 * @param alloc Allocator
 * @param slice Slicer
 * @param size Slab size
 * @returns Pooled allocator
 */
declare function util$pool(
  alloc: PoolAllocator,
  slice: PoolSlicer,
  size?: number
): PoolAllocator;

declare var npm$namespace$util$utf8: {
  length: typeof util$utf8$length,
  read: typeof util$utf8$read,
  write: typeof util$utf8$write
};

/**
 * Calculates the UTF8 byte length of a string.
 * @param string String
 * @returns Byte length
 */
declare function util$utf8$length(string: string): number;

/**
 * Reads UTF8 bytes as a string.
 * @param buffer Source buffer
 * @param start Source start
 * @param end Source end
 * @returns String read
 */
declare function util$utf8$read(
  buffer: Uint8Array,
  start: number,
  end: number
): string;

/**
 * Writes a string as UTF8 bytes.
 * @param string Source string
 * @param buffer Destination buffer
 * @param offset Destination offset
 * @returns Bytes written
 */
declare function util$utf8$write(
  string: string,
  buffer: Uint8Array,
  offset: number
): number;

/**
 * Generates a verifier specific to the specified message type.
 * @param mtype Message type
 * @returns Codegen instance
 */
declare export function verifier(mtype: Type): Codegen;

/**
 * Wrappers for common types.
 */
declare export var wrappers: {
  [k: string]: IWrapper
};
/**
 * From object converter part of an {@link IWrapper}.
 * @param object Plain object
 * @returns Message instance
 */
declare type WrapperFromObjectConverter = (object: {
  [k: string]: any
}) => Message<{}>;
/**
 * To object converter part of an {@link IWrapper}.
 * @param message Message instance
 * @param options Conversion options
 * @returns Plain object
 */
declare type WrapperToObjectConverter = (
  message: Message<{}>,
  options?: IConversionOptions
) => {
  [k: string]: any
};
/**
 * Common type wrapper part of {@link wrappers}.
 */
export interface IWrapper {
  /**
   * From object converter
   */
  fromObject?: WrapperFromObjectConverter;

  /**
   * To object converter
   */
  toObject?: WrapperToObjectConverter;
}
/**
 * Wire format writer using `Uint8Array` if available, otherwise `Array`.
 */
declare export class Writer {
  /**
   * Constructs a new writer instance.
   */
  constructor(): this;

  /**
   * Current length.
   */
  len: number;

  /**
   * Operations head.
   */
  head: { [key: string]: any };

  /**
   * Operations tail
   */
  tail: { [key: string]: any };

  /**
   * Linked forked states.
   */
  states: { [key: string]: any } | null;

  /**
   * Creates a new writer.
   * @returns A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
   */
  static create(): BufferWriter | Writer;

  /**
   * Allocates a buffer of the specified size.
   * @param size Buffer size
   * @returns Buffer
   */
  static alloc(size: number): Uint8Array;

  /**
   * Writes an unsigned 32 bit value as a varint.
   * @param value Value to write
   * @returns `this`
   */
  uint32(value: number): Writer;

  /**
   * Writes a signed 32 bit value as a varint.
   * @param value Value to write
   * @returns `this`
   */
  int32(value: number): Writer;

  /**
   * Writes a 32 bit value as a varint, zig-zag encoded.
   * @param value Value to write
   * @returns `this`
   */
  sint32(value: number): Writer;

  /**
   * Writes an unsigned 64 bit value as a varint.
   * @param value Value to write
   * @returns `this`
   * @throws {TypeError} If `value` is a string and no long library is present.
   */
  uint64(value: util$Long | number | string): Writer;

  /**
   * Writes a signed 64 bit value as a varint.
   * @param value Value to write
   * @returns `this`
   * @throws {TypeError} If `value` is a string and no long library is present.
   */
  int64(value: util$Long | number | string): Writer;

  /**
   * Writes a signed 64 bit value as a varint, zig-zag encoded.
   * @param value Value to write
   * @returns `this`
   * @throws {TypeError} If `value` is a string and no long library is present.
   */
  sint64(value: util$Long | number | string): Writer;

  /**
   * Writes a boolish value as a varint.
   * @param value Value to write
   * @returns `this`
   */
  bool(value: boolean): Writer;

  /**
   * Writes an unsigned 32 bit value as fixed 32 bits.
   * @param value Value to write
   * @returns `this`
   */
  fixed32(value: number): Writer;

  /**
   * Writes a signed 32 bit value as fixed 32 bits.
   * @param value Value to write
   * @returns `this`
   */
  sfixed32(value: number): Writer;

  /**
   * Writes an unsigned 64 bit value as fixed 64 bits.
   * @param value Value to write
   * @returns `this`
   * @throws {TypeError} If `value` is a string and no long library is present.
   */
  fixed64(value: util$Long | number | string): Writer;

  /**
   * Writes a signed 64 bit value as fixed 64 bits.
   * @param value Value to write
   * @returns `this`
   * @throws {TypeError} If `value` is a string and no long library is present.
   */
  sfixed64(value: util$Long | number | string): Writer;

  /**
   * Writes a float (32 bit).
   * @param value Value to write
   * @returns `this`
   */
  float(value: number): Writer;

  /**
   * Writes a double (64 bit float).
   * @param value Value to write
   * @returns `this`
   */
  double(value: number): Writer;

  /**
   * Writes a sequence of bytes.
   * @param value Buffer or base64 encoded string to write
   * @returns `this`
   */
  bytes(value: Uint8Array | string): Writer;

  /**
   * Writes a string.
   * @param value Value to write
   * @returns `this`
   */
  string(value: string): Writer;

  /**
   * Forks this writer's state by pushing it to a stack.
   * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
   * @returns `this`
   */
  fork(): Writer;

  /**
   * Resets this instance to the last state.
   * @returns `this`
   */
  reset(): Writer;

  /**
   * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
   * @returns `this`
   */
  ldelim(): Writer;

  /**
   * Finishes the write operation.
   * @returns Finished buffer
   */
  finish(): Uint8Array;
}
/**
 * Wire format writer using node buffers.
 */
declare export class BufferWriter mixins Writer {
  /**
   * Constructs a new buffer writer instance.
   */
  constructor(): this;

  /**
   * Finishes the write operation.
   * @returns Finished buffer
   */
  finish(): util$Buffer;

  /**
   * Allocates a buffer of the specified size.
   * @param size Buffer size
   * @returns Buffer
   */
  static alloc(size: number): util$Buffer;
}
/**
 * Callback as used by {@link util.asPromise}.
 * @param error Error, if any
 * @param params Additional arguments
 */
declare type asPromiseCallback = (
  error: Error | null,
  ...params: any[]
) => void;
/**
 * Appends code to the function's body or finishes generation.
 * @param formatStringOrScope Format string or, to finish the function, an object of additional scope variables, if any
 * @param formatParams Format parameters
 * @returns Itself or the generated function if finished
 * @throws {Error} If format parameter counts do not match
 */
declare type Codegen = (
  formatStringOrScope?:
    | string
    | {
        [k: string]: any
      },
  ...formatParams: any[]
) => Codegen | Function;
/**
 * Event listener as used by {@link util.EventEmitter}.
 * @param args Arguments
 */
declare type EventEmitterListener = (...args: any[]) => void;
/**
 * Node-style callback as used by {@link util.fetch}.
 * @param error Error, if any, otherwise `null`
 * @param contents File contents, if there hasn't been an error
 */
declare type FetchCallback = (error: Error, contents?: string) => void;
/**
 * Options as used by {@link util.fetch}.
 */
export interface IFetchOptions {
  /**
   * Whether expecting a binary response
   */
  binary?: boolean;

  /**
   * If `true`, forces the use of XMLHttpRequest
   */
  xhr?: boolean;
}
/**
 * An allocator as used by {@link util.pool}.
 * @param size Buffer size
 * @returns Buffer
 */
declare type PoolAllocator = (size: number) => Uint8Array;
/**
 * A slicer as used by {@link util.pool}.
 * @param start Start offset
 * @param end End offset
 * @returns Buffer slice
 */
declare type PoolSlicer = (start: number, end: number) => Uint8Array;
