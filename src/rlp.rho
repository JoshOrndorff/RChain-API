// Toward decoding ethereum signed transactions
// https://github.com/ethereum/wiki/wiki/RLP
new encode, decode, test,
ListOpsCh, hexByte, encodeLength, toBinary,
trace(`rho:io:stderr`), stdout(`rho:io:stdout`),
ri(`rho:registry:insertArbitrary`), rl(`rho:registry:lookup`)
in {
  // TODO: only register if all tests pass
  new uriCh in {
    // ISSUE: only export bundle+ (bummer it's not ocap-safe by default)
    ri!({"decode": *decode, "encode": *encode}, *uriCh) |
    for (@uri <- uriCh) {
      stdout!({"rlp uri": uri}) |
      rl!(uri, *uriCh)
    }
  } |

  // rl!(`rho:id:dputnspi15oxxnyymjrpu7rkaok3bjkiwq84z7cqcrx4ktqfpyapn4`, *ListOpsCh) |
  rl!(`rho:id:et17yw97tyhij463yctuxkbpes5s8xogwsbbbc54g3rm3f9g3ah3pa`, *ListOpsCh) |
  for(ListOps <- ListOpsCh) {
    trace!({"ListOps": *ListOps}) |

    contract encode(@item, return) = {
      // trace!({"encode item": item}) |
      match item {
        ByteArray => {
          // trace!({"ByteArray": item}) |
          if (item.length() <= 55) {
            new lenCh, notShort in {
              // rholang `and` does not short-circuit???
              if (item.length() == 1) {
                if (item.nth(0) <= 127) {
                  return!(item)
                } else { notShort!(Nil) }
              } else { notShort!(Nil) }
              |
              hexByte!(128 + item.length(), *lenCh) |
              for(_ <- notShort; @len <- lenCh) {
                // trace!({"bytes length": len}) |
                return!(len ++ item)
              }
            }
          } else {
            new llCh in {
              encodeLength!(item.length(), 128, *llCh) |
              for(@ll <- llCh) {
                return!(ll ++ item)
              }
            }
          }
        }
        [...items] => {
          // trace!({"List": item}) |
          new encodedEachCh, sum, totalCh, concat, payloadCh in {
            ListOps!("map", items, *encode, *encodedEachCh) |
            // TODO: handle done=true
            for(@encodedEach <- encodedEachCh) {
              // trace!({"encodedEach": encodedEach, "item": item}) |
              contract sum(@next, @subtot, return) = { return!(next.length() + subtot) } |
              contract concat(@tail, @head, return) = { return!(head ++ tail) } |
              ListOps!("fold", encodedEach, 0, *sum, *totalCh) |
              ListOps!("fold", encodedEach, "".hexToBytes(), *concat, *payloadCh) |
              for(@total <- totalCh; @payload <- payloadCh) {
                // trace!({"total length": total}) |
                if (total <= 55) {
                  new lenCh in {
                    hexByte!(192 + total, *lenCh) |
                    for(@len <- lenCh) {
                      // trace!({"total in hex": len, "item": item}) |
                      return!(len ++ payload)
                    }
                  }
                } else {
                  return!(("TODO: encode varint", items))
                }
              }
            }
          }
        }
        _ => {
          return!(("what???", item))
        }
      }
    }
  } |

  new hexCh in {
    hexCh!({
      0: "0", 1: "1", 2: "2", 3: "3",
      4: "4", 5: "5", 6: "6", 7: "7",
      8: "8", 9: "9", 10: "a", 11: "b",
      12: "c", 13: "d", 14: "e", 15: "f"
    }) |
    for(@hexDigit <- hexCh) {
      // singleton byte sequence
      contract hexByte(@{i /\ Integer}, return) = {
        // trace!({"hexByte": i}) |
        return!((hexDigit.get(i / 16) ++ hexDigit.get(i - (i / 16 * 16))).hexToBytes())
      }
    }
  } |

  // ISSUE: eject on overflow?
  contract encodeLength(@{length /\ Int}, @{bias /\ Int}, return) = {
    trace!({"length": length, "bias": bias}) |
    if (length < 56) {
      hexByte!(length + bias, *return)
    } else {
      new b256Ch, llCh in {
        toBinary!(length, *b256Ch) |
        for(@b256 <- b256Ch) {
          hexByte!(b256.length() + bias + 55, *llCh) |
          for(@ll <- llCh) {
            return!(ll ++ b256)
          }
        }
      }
    }
  } |
  contract toBinary(@{x /\ Int}, return) = {
    if (x <= 0) {
      return!("".hexToBytes())
    } else {
      new initCh, tailCh in {
        toBinary!(x / 256, *initCh) |
        hexByte!(x - ((x / 256) * 256), *tailCh) |
        for(@init <- initCh; @tail <- tailCh) {
          return!(init ++ tail)
        }
      }
    }
  } |


  contract decode(@{input /\ ByteArray}, fail, return) = {
    // trace!({"rlp input": input}) |
    new rlpAt, decodeLength, toInteger, outCh in {
      rlpAt!(0, input.length(), *outCh) |
      for(@out <- outCh) {
        // trace!({"out": out}) |
        if(out.get("next") == input.length()) {
          return!(out.get("item"))
        } else {
          fail!(out.get("next"))
        }
      }
      |
      contract rlpAt(@lo, @hi, return) = {
        new pfxCh in {
          decodeLength!(lo, hi, *pfxCh) |
          for (@pfx <- pfxCh) {
            // trace!({"decodeLength ->": pfx}) |
            if (pfx.get("list")) {
              new loop in {
                loop!([], pfx.get("lo"), pfx.get("hi")) |
                contract loop(@items, @here, @end) = {
                  // trace!({"list loop": [here, end], "items": items}) |
                  if (here == end) {
                    return!({"item": items, "next": end})
                  } else {
                    new stepCh in {
                      // trace!({"sub rlp lo": here, "hi": end,
                      //  "input length": input.length(), "items": items}) |
                      rlpAt!(here, end, *stepCh) |
                      for(@step <- stepCh) {
                        loop!(items ++ [step.get("item")], step.get("next"), end)
                      }
                    }
                  }
                }
              }
            } else {
              return!({
                "item": input.slice(pfx.get("lo"), pfx.get("hi")),
                "next": pfx.get("hi")
              })
            }
          }
        }
      }
      |
      contract decodeLength(@lo, @hi, return) = {
        // trace!({"decode lo": lo, "hi": hi, "len": input.length()}) |
        if (lo >= hi) {
          fail!(lo)
        } else if (input.nth(lo) <= 127 /* 0x7f */) {
          // trace!({"single byte": input.nth(lo), "at": lo}) |

          return!({"lo": lo, "hi": lo + 1, "list": false})
        } else if (input.nth(lo) <= 183 /* 0xb7 */) {
          // trace!({"short string at": lo}) |

          if (lo + 1 + input.nth(lo) - 128 > hi) {
            fail!(lo)
          } else {
            return!({
              "lo": lo + 1,
              "hi": lo + 1 + input.nth(lo) - 128,
              "list": false
            })
          }
        } else if (input.nth(lo) <= 191 /* 0xbf */) {
          // trace!({"long string at": lo}) |

          new qtyCh in {
            if (lo + 1 + input.nth(lo) - 183 > hi) {
              fail!(lo)
            } else {
              toInteger!(lo + 1, lo + 1 + input.nth(lo) - 183, *qtyCh) |
              for (@qty <- qtyCh) {
                if (lo + 1 + input.nth(lo) - 183 + qty > hi) {
                  fail!(lo + 1)
                } else {
                  return!({
                    "lo": lo + 1 + input.nth(lo) - 183,
                    "hi": lo + 1 + input.nth(lo) - 183 + qty,
                    "list": false
                  })
                }
              }
            }
          }
        } else if (input.nth(lo) <= 247 /* 0xf7 */) {
          // trace!({"short list at": lo}) |

          if (lo + 1 + input.nth(lo) - 192 > hi) {
            fail!(lo)
          } else {
            return!({
              "lo": lo + 1,
              "hi": lo + 1 + input.nth(lo) - 192,
              "list": true
            })
          }
        } else {
          // trace!({"long list at": lo}) |

          if (lo + input.nth(lo) - 246 > hi) {
            fail!({"at": lo, "long list length size": lo + 1 + input.nth(lo) - 246})
          } else {
            new qtyCh in {
              toInteger!(lo + 1, lo + input.nth(lo) - 246, *qtyCh) |
              for (@listLen <- qtyCh) {
                if (lo + input.nth(lo) - 246 + listLen > hi) {
                  fail!({
                    "at": lo + 1,
                    "long list data size": lo + input.nth(lo) - 246 + listLen
                  })
                } else {
                  return!({
                    "lo": lo + input.nth(lo) - 246,
                    "hi": lo + input.nth(lo) - 246 + listLen,
                    "list": true
                  })
                }
              }
            }
          }
        }
      }
      |
      contract toInteger(@lo, @hi, return) = {
        // trace!({"toInteger lo": lo, "hi": hi}) |
        if (hi <= lo) {
          return!(0)
        } else if (hi - lo == 1) {
          // trace!({"toInteger base": input.nth(lo)}) |
          return!(input.nth(lo))
        } else {
          new recur in {
            toInteger!(lo, hi - 1, *recur) |
            for(@bb <- recur) {
              // trace!({"toInteger recur": input, "lo": lo, "hi": hi}) |
              return!(input.nth(hi - 1) + bb * 256)
            }
          }
        }
      }
    }
  }
  |
  contract test(@label, @inputHex, @expected, ack) = {
    new errCh, okCh in {
      decode!(inputHex.hexToBytes(), *errCh, *okCh) |
      for (@ix <- errCh) {
        trace!({"test decode": label, "failAt": ix, "input": inputHex, "expected": expected})
      } |
      for (@x <- okCh) {
        if (x == expected) {
          trace!({"pass decode": label})
        } else {
          trace!({"FAIL decode": label, "actual": x, "expected": expected})
        }
      }
    } |

    new encodedCh in {
      encode!(expected, *encodedCh) |
      for (@actual <- encodedCh) {
        if (actual == inputHex.hexToBytes()) {
          trace!({"pass encode": label})
        } else {
          trace!({"FAIL encode": label, "actual": actual, "expected": inputHex})
        }
      }
    }
  }
  |

  test!("ill-formed", "", Nil, Nil) |
  test!("The string \"dog\"", "83646f67", "646f67".hexToBytes(), Nil) |
  test!("The empty string ('null')", "80", "".hexToBytes(), Nil) |
  test!("The integer 0", "80", "".hexToBytes(), Nil) |
  test!("The empty list", "c0", [], Nil) |
  test!("The encoded integer 0", "00", "00".hexToBytes(), Nil) |
  test!("The encoded integer 15", "0f", "0f".hexToBytes(), Nil) |
  test!("The encoded integer 1024", "820400", "0400".hexToBytes(), Nil) |
  test!("The string \"Lorem ipsum dolor sit amet, consectetur adipisicing elit\"",
   "b8384c6f72656d20697073756d20646f6c6f722073697420616d65742c20636f6e7365637465747572206164697069736963696e6720656c6974",
   "4c6f72656d20697073756d20646f6c6f722073697420616d65742c20636f6e7365637465747572206164697069736963696e6720656c6974".hexToBytes(), Nil) |
  test!("The set theoretical representation of three",
   "c7c0c1c0c3c0c1c0", [ [], [[]], [ [], [[]] ] ], Nil) |
  test!("The list [ \"cat\", \"dog\" ]", "c88363617483646f67",
    ["636174".hexToBytes(), "646f67".hexToBytes()], Nil) |

  test!("EIP155 test case",
    "f864808504a817c800825208943535353535353535353535353535353535353535808025a0044852b2a670ade5407e78fb2863c51de9fcb96542a07186fe3aeda6bb8a116da0044852b2a670ade5407e78fb2863c51de9fcb96542a07186fe3aeda6bb8a116d",
    [
      "".hexToBytes(),        // nonce
      "4a817c800".hexToBytes(), // gasPrice
      "5208".hexToBytes(),      // gasLimit
      "3535353535353535353535353535353535353535".hexToBytes(),  // to
      "".hexToBytes(), // value
      "".hexToBytes(), // data
      "25".hexToBytes(), // v
      "044852b2a670ade5407e78fb2863c51de9fcb96542a07186fe3aeda6bb8a116d".hexToBytes(),  // r
      "044852b2a670ade5407e78fb2863c51de9fcb96542a07186fe3aeda6bb8a116d".hexToBytes()  // s
    ], Nil) |

  
  trace!("testing")
}
