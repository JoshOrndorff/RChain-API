// Toward decoding ethereum signed transactions
// https://github.com/ethereum/wiki/wiki/RLP
new rlp, test, trace(`rho:io:stderr`) in {
  contract rlp(@{input /\ ByteArray}, fail, return) = {
    // trace!({"rlp input": input}) |
    new rlpAt, decodeLength, toInteger, outCh in {
      rlpAt!(0, input.length(), *outCh) |
      for(@out <- outCh) {
        // trace!({"out": out}) |
        if(out.get("next") == input.length()) {
          return!(out.get("item"))
        } else {
          fail!(out.get("next"))
        }
      }
      |
      contract rlpAt(@lo, @hi, return) = {
        new pfxCh in {
          decodeLength!(lo, hi, *pfxCh) |
          for (@pfx <- pfxCh) {
            // trace!({"decodeLength ->": pfx}) |
            if (pfx.get("list")) {
              new loop in {
                loop!([], pfx.get("lo"), pfx.get("hi")) |
                contract loop(@items, @here, @end) = {
                  // trace!({"list loop": [here, end], "items": items}) |
                  if (here == end) {
                    return!({"item": items, "next": end})
                  } else {
                    new stepCh in {
                      // trace!({"sub rlp lo": here, "hi": end,
                      //  "input length": input.length(), "items": items}) |
                      rlpAt!(here, end, *stepCh) |
                      for(@step <- stepCh) {
                        loop!(items ++ [step.get("item")], step.get("next"), end)
                      }
                    }
                  }
                }
              }
            } else {
              return!({
                "item": input.slice(pfx.get("lo"), pfx.get("hi")),
                "next": pfx.get("hi")
              })
            }
          }
        }
      }
      |
      contract decodeLength(@lo, @hi, return) = {
        // trace!({"decode lo": lo, "hi": hi, "len": input.length()}) |
        if (lo >= hi) {
          fail!(lo)
        } else if (input.nth(lo) <= 127 /* 0x7f */) {
          // trace!({"single byte": input.nth(lo), "at": lo}) |

          return!({"lo": lo, "hi": lo + 1, "list": false})
        } else if (input.nth(lo) <= 183 /* 0xb7 */) {
          // trace!({"short string at": lo}) |

          if (lo + 1 + input.nth(lo) - 128 > hi) {
            fail!(lo)
          } else {
            return!({
              "lo": lo + 1,
              "hi": lo + 1 + input.nth(lo) - 128,
              "list": false
            })
          }
        } else if (input.nth(lo) <= 191 /* 0xbf */) {
          // trace!({"long string at": lo}) |

          new qtyCh in {
            if (lo + 1 + input.nth(lo) - 183 > hi) {
              fail!(lo)
            } else {
              toInteger!(lo + 1, lo + 1 + input.nth(lo) - 183, *qtyCh) |
              for (@qty <- qtyCh) {
                if (lo + 1 + input.nth(lo) - 183 + qty > hi) {
                  fail!(lo + 1)
                } else {
                  return!({
                    "lo": lo + 1 + input.nth(lo) - 183,
                    "hi": lo + 1 + input.nth(lo) - 183 + qty,
                    "list": false
                  })
                }
              }
            }
          }
        } else if (input.nth(lo) <= 247 /* 0xf7 */) {
          // trace!({"short list at": lo}) |

          if (lo + 1 + input.nth(lo) - 192 > hi) {
            fail!(lo)
          } else {
            return!({
              "lo": lo + 1,
              "hi": lo + 1 + input.nth(lo) - 192,
              "list": true
            })
          }
        } else {
          // trace!({"long list at": lo}) |

          if (lo + input.nth(lo) - 246 > hi) {
            fail!({"at": lo, "long list length size": lo + 1 + input.nth(lo) - 246})
          } else {
            new qtyCh in {
              toInteger!(lo + 1, lo + input.nth(lo) - 246, *qtyCh) |
              for (@listLen <- qtyCh) {
                if (lo + input.nth(lo) - 246 + listLen > hi) {
                  fail!({
                    "at": lo + 1,
                    "long list data size": lo + input.nth(lo) - 246 + listLen
                  })
                } else {
                  return!({
                    "lo": lo + input.nth(lo) - 246,
                    "hi": lo + input.nth(lo) - 246 + listLen,
                    "list": true
                  })
                }
              }
            }
          }
        }
      }
      |
      contract toInteger(@lo, @hi, return) = {
        // trace!({"toInteger lo": lo, "hi": hi}) |
        if (hi <= lo) {
          return!(0)
        } else if (hi - lo == 1) {
          // trace!({"toInteger base": input.nth(lo)}) |
          return!(input.nth(lo))
        } else {
          new recur in {
            toInteger!(lo, hi - 1, *recur) |
            for(@bb <- recur) {
              // trace!({"toInteger recur": input, "lo": lo, "hi": hi}) |
              return!(input.nth(hi - 1) + bb * 256)
            }
          }
        }
      }
    }
  }
  |
  contract test(@label, @inputHex, @expected, ack) = {
    new errCh, okCh in {
      rlp!(inputHex.hexToBytes(), *errCh, *okCh) |
      for (@ix <- errCh) {
        trace!({"test": label, "failAt": ix, "input": inputHex, "expected": expected})
      } |
      for (@x <- okCh) {
        if (x == expected) {
          trace!({"pass": label})
        } else {
          trace!({"FAIL": label, "actual": x, "expected": expected})
        }
      }
    }
  }
  |

  test!("ill-formed", "", Nil, Nil) |
  test!("The string \"dog\"", "83646f67", "646f67".hexToBytes(), Nil) |
  test!("The empty string ('null')", "80", "".hexToBytes(), Nil) |
  test!("The integer 0", "80", "".hexToBytes(), Nil) |
  test!("The empty list", "c0", [], Nil) |
  test!("The encoded integer 0", "00", "00".hexToBytes(), Nil) |
  test!("The encoded integer 15", "0f", "0f".hexToBytes(), Nil) |
  test!("The encoded integer 1024", "820400", "0400".hexToBytes(), Nil) |
  test!("The string \"Lorem ipsum dolor sit amet, consectetur adipisicing elit\"",
   "b8384c6f72656d20697073756d20646f6c6f722073697420616d65742c20636f6e7365637465747572206164697069736963696e6720656c6974",
   "4c6f72656d20697073756d20646f6c6f722073697420616d65742c20636f6e7365637465747572206164697069736963696e6720656c6974".hexToBytes(), Nil) |
  test!("The set theoretical representation of three",
   "c7c0c1c0c3c0c1c0", [ [], [[]], [ [], [[]] ] ], Nil) |
  test!("The list [ \"cat\", \"dog\" ]", "c88363617483646f67",
    ["636174".hexToBytes(), "646f67".hexToBytes()], Nil) |

  test!("EIP155 test case",
    "f864808504a817c800825208943535353535353535353535353535353535353535808025a0044852b2a670ade5407e78fb2863c51de9fcb96542a07186fe3aeda6bb8a116da0044852b2a670ade5407e78fb2863c51de9fcb96542a07186fe3aeda6bb8a116d",
    [
      "".hexToBytes(),        // nonce
      "4a817c800".hexToBytes(), // gasPrice
      "5208".hexToBytes(),      // gasLimit
      "3535353535353535353535353535353535353535".hexToBytes(),  // to
      "".hexToBytes(), // value
      "".hexToBytes(), // data
      "25".hexToBytes(), // v
      "044852b2a670ade5407e78fb2863c51de9fcb96542a07186fe3aeda6bb8a116d".hexToBytes(),  // r
      "044852b2a670ade5407e78fb2863c51de9fcb96542a07186fe3aeda6bb8a116d".hexToBytes()  // s
    ], Nil) |

  trace!("testing")
}
