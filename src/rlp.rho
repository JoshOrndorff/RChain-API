// Toward decoding ethereum signed transactions
// https://github.com/ethereum/wiki/wiki/RLP
new encode, decode, oneByte, encodeVarInt, decodeVarInt,
    ListOpsCh, test,
    trace(`rho:io:stderr`), stdout(`rho:io:stdout`),
    ri(`rho:registry:insertArbitrary`), rl(`rho:registry:lookup`)
in {
  // TODO: only register if all tests pass
  new uriCh in {
    ri!({
      "decode": bundle+{*decode},
      "encode": bundle+{*encode},
      "encodeVarInt": bundle+{*encodeVarInt},
      "decodeVarInt": bundle+{*decodeVarInt},
      "oneByte": bundle+{*oneByte}
    }, *uriCh) |
    for (@uri <- uriCh) {
      stdout!({"rlp uri": uri}) |
      rl!(uri, *uriCh)
    }
  } |

  rl!(`rho:id:dputnspi15oxxnyymjrpu7rkaok3bjkiwq84z7cqcrx4ktqfpyapn4`, *ListOpsCh) |
  for(ListOps <- ListOpsCh) {
    trace!({"ListOps": *ListOps}) |

    contract encode(@item, return) = {
      // trace!({"encode item": item}) |
      new shortItem, longItem, concat in {
        match item {
          ByteArray => {
            if (item.length() == 1) {
              // rholang `and` does not short-circuit???
              if (item.nth(0) < 8 * 16) { return!(item) }
              else { longItem!(8 * 16, item, *return) }
            } else { longItem!(8 * 16, item, *return) }
          }
          [...items] => {
            // trace!({"List": item}) |
            new payloadCh in {
              concat!(item, *payloadCh) |
              for(@payload <- payloadCh) {
                longItem!(12 * 16, payload, *return)
              }
            }
          }
          _ => {
            return!(("what???", item))
          }
        } |

        contract longItem(@{bias /\ Int}, @{payload /\ ByteArray}, return) = {
          if (payload.length() <= 55) {
            shortItem!(bias, payload, *return)
          } else {
            new encodedLengthCh, b0Ch in {
              encodeVarInt!(payload.length(), *encodedLengthCh) |
              for(@encodedLength <- encodedLengthCh) {
                oneByte!(bias + 55 + encodedLength.length(), *b0Ch) |
                for(@b0 <- b0Ch) {
                  return!(b0 ++ encodedLength ++ payload)
                }
              }
            }
          }
        } |

        contract shortItem(@{bias /\ Int}, @{payload /\ ByteArray}, return) = {
          new lenCh in {
            oneByte!(bias + payload.length(), *lenCh) |
            for(@len <- lenCh) {
              // trace!({"bytes length": len}) |
              return!(len ++ payload)
            }
          }
        } |

        contract concat(@items, return) = {
          new encodedEachCh, step in {
            ListOps!("map", items, *encode, *encodedEachCh) |
            for(@encodedEach <- encodedEachCh) {
              // trace!({"encodedEach": encodedEach, "item": item}) |
              contract step(@tail, @head, return) = { return!(head ++ tail) } |
              ListOps!("fold", encodedEach, "".hexToBytes(), *step, *return)
            }
          }
        }
      }
    }
  } |

  new hexCh in {
    hexCh!({
      0: "0", 1: "1", 2: "2", 3: "3",
      4: "4", 5: "5", 6: "6", 7: "7",
      8: "8", 9: "9", 10: "a", 11: "b",
      12: "c", 13: "d", 14: "e", 15: "f"
    }) |
    for(@hexDigit <- hexCh) {
      // singleton byte sequence
      contract oneByte(@{i /\ Integer}, return) = {
        // trace!({"oneByte": i}) |
        return!((hexDigit.get(i / 16) ++ hexDigit.get(i - (i / 16 * 16))).hexToBytes())
      }
    }
  } |

  contract encodeVarInt(@{x /\ Int}, return) = {
    if (x <= 0) {
      return!("".hexToBytes())
    } else {
      new initCh, tailCh in {
        encodeVarInt!(x / 256, *initCh) |
        oneByte!(x - ((x / 256) * 256), *tailCh) |
        for(@init <- initCh; @tail <- tailCh) {
          return!(init ++ tail)
        }
      }
    }
  } |


  contract decode(@{input /\ ByteArray}, fail, return) = {
    // trace!({"rlp input": input}) |
    new decodeItem, outCh in {
      decodeItem!(0, input.length(), *outCh) |
      for(@item, @next <- outCh) {
        // trace!({"item": item, "next": next}) |
        if(next == input.length()) {
          return!(item)
        } else {
          fail!(next)
        }
      }
      |
      contract decodeItem(@lo, @hi, return) = {
        if (lo >= hi) { fail!(lo) }
        else {
          new stringOrList, returnSlice,
          decodeString, shortString, longString,
          decodeList, shortList, longList, listItems in {
            stringOrList!(input.nth(lo))
            |
            contract stringOrList(@b0) = {
              if (b0 <= 127 /* 0x7f */) { returnSlice!(lo, lo + 1) }
              else if (b0 <= 191 /* 0xbf */) { decodeString!(lo + 1) }
              else { decodeList!(lo + 1) }
              |
              contract returnSlice(@lo, @hi) = { return!(input.slice(lo, hi), hi) } |
              contract decodeString(@lo1) = {
                // trace!({"decodeString": lo1, "b0": b0}) |
                if (b0 <= 183 /* 0xb7 */) { shortString!(lo1 + b0 - 128) }
                else { longString!(lo1 + b0 - 183) }
                |
                contract shortString(@end) = {
                  if (end > hi) { fail!(lo) }
                  else { returnSlice!(lo1, end) }
                }
                |
                contract longString(@lenEnd) = {
                  if (lenEnd > hi) { fail!(lo1) }
                  else {
                    new strLenCh in {
                      decodeVarInt!(input, lo1, lenEnd, *strLenCh) | for (@strLen <- strLenCh) {
                        if (lenEnd + strLen > hi) { fail!(lo1) }
                        else { returnSlice!(lenEnd, lenEnd + strLen) }
                      }
                    }
                  }
                }
              }
              |
              contract decodeList(@lo1) = {
                if (b0 <= 247 /* 0xf7 */) { shortList!(lo1 + b0 - 192 /* 0xc0*/) }
                else { longString!(lo1 + b0 - 247) }
                |
                contract shortList(@end) = {
                  if (end > hi) { fail!(lo) }
                  else { listItems!([], lo1, end) }
                }
                |
                contract longList(@lenEnd) = {
                  if (lenEnd > hi) { fail!(lo1) }
                  else {
                    new listLenCh in {
                      decodeVarInt!(input, lo1, lenEnd, *listLenCh) | for (@listLen <- listLenCh) {
                        if (lo1 + listLen > hi) { fail!(lo1) }
                        else { listItems!([], lenEnd, lo1 + lenEnd) }
                      }
                    }
                  }
                }
              }
              |
              contract listItems(@items, @here, @end) = {
                // trace!({"list loop": [here, end], "items": items}) |
                if (here == end) { return!(items, end) }
                else {
                  new stepCh in {
                    // trace!({"sub rlp lo": here, "hi": end,
                    //  "input length": input.length(), "items": items}) |
                    decodeItem!(here, end, *stepCh) |
                    for(@item, @next <- stepCh) {
                      listItems!(items ++ [item], next, end)
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  |
  contract decodeVarInt(@input, @lo, @hi, return) = {
    // trace!({"toInteger lo": lo, "hi": hi}) |
    if (hi <= lo) {
      return!(0)
    } else if (hi - lo == 1) {
      // trace!({"toInteger base": input.nth(lo)}) |
      return!(input.nth(lo))
    } else {
      new recur in {
        decodeVarInt!(lo, hi - 1, *recur) |
        for(@bb <- recur) {
          // trace!({"toInteger recur": input, "lo": lo, "hi": hi}) |
          return!(input.nth(hi - 1) + bb * 256)
        }
      }
    }
  }
  |
  contract test(@label, @inputHex, @expected, ack) = {
    new errCh, okCh in {
      decode!(inputHex.hexToBytes(), *errCh, *okCh) |
      for (@ix <- errCh) {
        trace!({"test decode": label, "failAt": ix, "input": inputHex, "expected": expected})
      } |
      for (@x <- okCh) {
        if (x == expected) {
          trace!({"pass decode": label})
        } else {
          trace!({"FAIL decode": label, "actual": x, "expected": expected})
        }
      }
    } |

    new encodedCh in {
      encode!(expected, *encodedCh) |
      for (@actual <- encodedCh) {
        if (actual == inputHex.hexToBytes()) {
          trace!({"pass encode": label})
        } else {
          trace!({"FAIL encode": label, "actual": actual, "expected": inputHex})
        }
      }
    }
  }
  |

  test!("ill-formed", "", Nil, Nil) |
  test!("The string \"dog\"", "83646f67", "646f67".hexToBytes(), Nil) |
  test!("The empty string ('null')", "80", "".hexToBytes(), Nil) |
  test!("The integer 0", "80", "".hexToBytes(), Nil) |
  test!("The empty list", "c0", [], Nil) |
  test!("The encoded integer 0", "00", "00".hexToBytes(), Nil) |
  test!("The encoded integer 15", "0f", "0f".hexToBytes(), Nil) |
  test!("The encoded integer 1024", "820400", "0400".hexToBytes(), Nil) |
  test!("The string \"Lorem ipsum dolor sit amet, consectetur adipisicing elit\"",
   "b8384c6f72656d20697073756d20646f6c6f722073697420616d65742c20636f6e7365637465747572206164697069736963696e6720656c6974",
   "4c6f72656d20697073756d20646f6c6f722073697420616d65742c20636f6e7365637465747572206164697069736963696e6720656c6974".hexToBytes(), Nil) |
  test!("The set theoretical representation of three",
   "c7c0c1c0c3c0c1c0", [ [], [[]], [ [], [[]] ] ], Nil) |
  test!("The list [ \"cat\", \"dog\" ]", "c88363617483646f67",
    ["636174".hexToBytes(), "646f67".hexToBytes()], Nil) |

  test!("EIP155 test case",
    "f864808504a817c800825208943535353535353535353535353535353535353535808025a0044852b2a670ade5407e78fb2863c51de9fcb96542a07186fe3aeda6bb8a116da0044852b2a670ade5407e78fb2863c51de9fcb96542a07186fe3aeda6bb8a116d",
    [
      "".hexToBytes(),        // nonce
      "4a817c800".hexToBytes(), // gasPrice
      "5208".hexToBytes(),      // gasLimit
      "3535353535353535353535353535353535353535".hexToBytes(),  // to
      "".hexToBytes(), // value
      "".hexToBytes(), // data
      "25".hexToBytes(), // v
      "044852b2a670ade5407e78fb2863c51de9fcb96542a07186fe3aeda6bb8a116d".hexToBytes(),  // r
      "044852b2a670ade5407e78fb2863c51de9fcb96542a07186fe3aeda6bb8a116d".hexToBytes()  // s
    ], Nil) |


  trace!("testing")
}
