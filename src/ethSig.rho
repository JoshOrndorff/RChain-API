new trace(`rho:io:stderr`), rl(`rho:registry:lookup`), itemsCh,
validateTransaction, pkDER, sigDER, rlpCh in {
  rl!(`rho:id:epm7u46j9h7yzqsrx7kffyaxotcc1ma76z4om7ui8hiewdpjdotakh`, *rlpCh) |

  trace!("ethereumjs-tx README test case") |

  validateTransaction!(
    // tx.serialize().toString('hex')
    "f889808609184e72a00082271094000000000000000000000000000000000000000080a47f746573743200000000000000000000000000000000000000000000000000000060005729a0f2d54d3399c9bcd3ac3482a5ffaeddfe68e9a805375f626b4f2f8cf530c2d95aa05b3bb54e6e8db52083a9b674e578c843a87c292f0383ddba168573808d36dc8e".hexToBytes(),
    // > tx.getSenderPublicKey().toString('hex')
    ("6d9038945ff8f4669201ba1e806c9a46a5034a578e4d52c03152198538039294" ++
      "4efd6c702504d9130573bb939f5c124af95d38168546cc7207a7e0baf14172ff").hexToBytes(),
    *itemsCh) |

  for(@(true, [nonce, gasPrice, gasLimit, to, value, data, v, r, s]) <- itemsCh) {
    trace!({"valid tx": [nonce, gasPrice, gasLimit, to, value, data, v, r, s]})
  } |

  // ASN1 Distinguished Encoding Rules (DER) for public key
  contract pkDER(@{pk /\ ByteArray}, return) = {
    trace!({"pkDER": pk}) |
    return!("${OctetString}${pk}".toUtf8Bytes() %% { "OctetString": 4, "pk": pk })
  }
  |
  // ASN1 Distinguished Encoding Rules (DER) for signature
  // i.e. SEQUENCE { r INTEGER, S INTEGER }
  contract sigDER(@{r /\ ByteArray}, @{s /\ ByteArray}, return) = {
    trace!({"sigDERr": r, "s": s}) |
    new zpad, rpCh, spCh in {
      zpad!(r, *rpCh) | zpad!(s, *spCh) |
      for(@rp <- rpCh; @sp <- spCh) {
        return!("${SEQUENCE}${lenRS}${INTEGER}${lenR}${r}${INTEGER}${lenS}${s}".toUtf8Bytes() %% {
          "SEQUENCE": 48,  // 0x20 + tag 0x10
          "lenRS": 2 + 1 + 1 + r.length() + 1 + s.length(),
          "INTEGER": 2,
          "r": rp, "lenR": rp.length(),
          "s": sp, "lenS": sp.length()
        })
      } |
      contract zpad(@{bn /\ ByteArray}, return) = {
        // trace!({"zpad": bn.nth(0)}) |
        if (bn.nth(0) >= 128) {
          return!("00".hexToBytes() ++ bn)
        } else {
          return!(bn)
        }
      }
    }
  } |

  // ISSUE: the public key can be recovered from the signature, but
  // rholang doesn't expose `ecrecover` (yet?)
  // so we have the caller supply the pk.
  contract validateTransaction(@{msg /\ ByteArray}, @{pk /\ ByteArray}, return) = {

    for(rlp <- rlpCh) { // ISSUE: hoist rlp binding?
      new itemsCh, sigCh, pubCh in {
        pkDER!(pk, *pubCh) |

        rlp!(msg, *trace, *itemsCh) |
        for(@[nonce, gasPrice, gasLimit, to, value, data, v, r, s] <- itemsCh) {
          trace!({"tx": [nonce, gasPrice, gasLimit, to, value, data, v, r, s]}) |
          new hashCh, verifyCh in {
            // msg is 139 bytes long
            // "19".hexToBytes() ++ "Ethereum Signed Message:\n139".toUtf8Bytes() ++
            // @"keccak256Hash"!(msg, *hashCh) |

            // > tx.hash(false).toString('hex')
            // or, equivalently:
            // const zb = Buffer.from([])
            // > ethUtil.rlphash([tx.nonce, tx.gasPrice, tx.gasLimit, tx.to, tx.value, tx.data, ethUtil.toBuffer(tx._chainId), zb, zb])
            hashCh!("df2a7cb6d05278504959987a144c116dbd11cbdc50d6482c5bae84a7f41e2113".hexToBytes()) |

            sigDER!(r, s, *sigCh) |

            for(@hash <- hashCh; @sig <- sigCh; @pk <- pubCh) {
              trace!({"hash": hash}) |

              trace!({"verifying sig": sig, "over": hash, "pubKey": pk}) |
              @"secp256k1Verify"!(hash, sig, pk, *verifyCh) |
              for (@ok <- verifyCh) {
                trace!({"sig ok?": ok}) |
                if (ok) {
                  return!((true, [nonce, gasPrice, gasLimit, to, value, data, v, r, s]))
                } else {
                  return!((false, Nil)) // ISSUE: use separate return channel instead?
                }
              }
            }
          }
        }
      }
    }
  }
}
