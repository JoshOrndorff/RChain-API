new trace(`rho:io:stderr`), rl(`rho:registry:lookup`),
rCh, bufCh, pubCh, sigCh, itemsCh,
sigDER, pkDER in
{
  rl!(`rho:id:gbxhost7zscewrxsghqgc9nnwaju1h8xthemunp7661aum8z1nb6ye`, *rCh) |

  trace!("ethereumjs-tx README test case") |

  // tx.serialize().toString('hex')
  bufCh!("f889808609184e72a00082271094000000000000000000000000000000000000000080a47f746573743200000000000000000000000000000000000000000000000000000060005729a0f2d54d3399c9bcd3ac3482a5ffaeddfe68e9a805375f626b4f2f8cf530c2d95aa05b3bb54e6e8db52083a9b674e578c843a87c292f0383ddba168573808d36dc8e".hexToBytes()) |

  pkDER!(
    // > tx.getSenderPublicKey().toString('hex')
    ("6d9038945ff8f4669201ba1e806c9a46a5034a578e4d52c03152198538039294" ++
      "4efd6c702504d9130573bb939f5c124af95d38168546cc7207a7e0baf14172ff"),
    *pubCh) |

  sigDER!(
    "00" ++ // TODO: prevent f2 from signaling negative in sigDER
    // > tx.r.toString('hex')
    "f2d54d3399c9bcd3ac3482a5ffaeddfe68e9a805375f626b4f2f8cf530c2d95a",
    // > tx.s.toString('hex')
    "5b3bb54e6e8db52083a9b674e578c843a87c292f0383ddba168573808d36dc8e",
    *sigCh) |

  // ASN1 Distinguished Encoding Rules (DER) for public key
  // TODO: ++ on ByteArray
  contract pkDER(@{pk /\ String}, return) = {
    trace!({"pkDER": pk}) |
    return!(("04" ++ // OctetString tagged
      pk).hexToBytes())
  }
  |
  contract sigDER(@{r /\ String}, @{s /\ String}, return) = {
    trace!({"sigDERr": r, "s": s}) |
    // stupid Rholang tricks...
    new lenRSCh, lenRCh, lenSCh, hexDigit, hexByte in {
      for(@lenRS <- lenRSCh; @lenR <- lenRCh; @lenS <- lenSCh) {
        trace!({"lenRS": lenRS}) |
        return!((
          // DER Sequence (tag 16); 4 + lenR + lenS
          "30" ++ lenRS ++
            // DER Integer
            "02" ++ lenR ++ r ++
            "02" ++ lenS ++ s).hexToBytes())
      } |
      hexByte!(4 + (r.length() + s.length()) / 2, *lenRSCh) |
      hexByte!(r.length() / 2, *lenRCh) | hexByte!(s.length() / 2, *lenSCh) |

      // singleton byte sequence
      // TODO: add Rholang method to make ByteArray from list of int
      // TODO: add ++ on ByteArray
      contract hexByte(@{i /\ Integer}, return) = {
        trace!({"hexByte": i}) |
        new d0Ch, d1Ch in {
          hexDigit!(i / 16, *d1Ch) |
          hexDigit!(i - (i / 16 * 16), *d0Ch) |
          for(@d0 <- d0Ch; @d1 <- d1Ch) {
            return!(d1 ++ d0)
          }
        }
      } |
      contract hexDigit(@{i /\ Integer}, d) = {
        trace!({"hexDigit": i}) |
        match i {
          0 => { d!("0") } 1 => { d!("1") } 2 => { d!("2") } 3 => { d!("3") }
          4 => { d!("4") } 5 => { d!("5") } 6 => { d!("6") } 7 => { d!("7") }
          8 => { d!("8") } 9 => { d!("9") } 10 => { d!("a") } 11 => { d!("b") }
          12 => { d!("c") } 13 => { d!("d") } 14 => { d!("e") } 15 => { d!("f") }
          _ => trace!({ "bad hex digit": i })
        }
      }
    }
  } |

  // test from
  // https://github.com/bitcoin-core/secp256k1/blob/master/src/java/org/bitcoin/NativeSecp256k1Test.java
  // data CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90
  // sig   3044022079
  //           BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F8179802
  //       2029
  //           4F14E883B3F525B5367756C2A11EF6CF84B730B36C17CB0C56F0AAB2C98589
  // pub 040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40

  for(rlp <- rCh; @msg <- bufCh; @pk <- pubCh; @sig <- sigCh) {
    rlp!(msg, *trace, *itemsCh) |
    for(@[nonce, gasPrice, gasLimit, to, value, data, v, r, s] <- itemsCh) {
      trace!({"tx": [nonce, gasPrice, gasLimit, to, value, data, v, r, s]}) |
      new hashCh, verifyCh in {
        // msg is 139 bytes long
        // "19".hexToBytes() ++ "Ethereum Signed Message:\n139".toUtf8Bytes() ++
        // @"keccak256Hash"!(msg, *hashCh) |

        // > tx.hash(false).toString('hex')
        // or, equivalently:
        // const zb = Buffer.from([])
        // > ethUtil.rlphash([tx.nonce, tx.gasPrice, tx.gasLimit, tx.to, tx.value, tx.data, ethUtil.toBuffer(tx._chainId), zb, zb])
        hashCh!("df2a7cb6d05278504959987a144c116dbd11cbdc50d6482c5bae84a7f41e2113".hexToBytes()) |

        for(@hash <- hashCh) {
          trace!({"hash": hash}) |

          trace!({"verifying sig": sig, "over": hash, "pubKey": pk}) |
          @"secp256k1Verify"!(hash, sig, pk, *verifyCh) |
          for (@ok <- verifyCh) {
            trace!({"sig ok?": ok})
          }
        }
      }
    }
  }
}
