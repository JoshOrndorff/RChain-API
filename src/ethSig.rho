new trace(`rho:io:stderr`), rl(`rho:registry:lookup`), rCh, bufCh, pubCh, sigCh, itemsCh in {
  rl!(`rho:id:gbxhost7zscewrxsghqgc9nnwaju1h8xthemunp7661aum8z1nb6ye`, *rCh) |

  trace!("ethereumjs-tx README test case") |

  // tx.serialize().toString('hex')
  bufCh!("f889808609184e72a00082271094000000000000000000000000000000000000000080a47f746573743200000000000000000000000000000000000000000000000000000060005729a0f2d54d3399c9bcd3ac3482a5ffaeddfe68e9a805375f626b4f2f8cf530c2d95aa05b3bb54e6e8db52083a9b674e578c843a87c292f0383ddba168573808d36dc8e".hexToBytes()) |

  // tx.getSenderPublicKey().toString('hex')
  // odd... extra 04 on the front:
  // scala> Base16.encode(Secp256k1.toPublic(pr))
  // res2: String = 046d90
  pubCh!(("04" ++ // what is this prefix byte for / from???
          "6d9038945ff8f4669201ba1e806c9a46a5034a578e4d52c03152198538039294" ++
          "4efd6c702504d9130573bb939f5c124af95d38168546cc7207a7e0baf14172ff").hexToBytes()) |

  // r ++ s
  sigCh!((
          "3045022100" ++ // where did these bytes come from?
              "f2d54d3399c9bcd3ac3482a5ffaeddfe68e9a805375f626b4f2f8cf530c2d95a" ++
          "0220" ++  // and these?
              "5b3bb54e6e8db52083a9b674e578c843a87c292f0383ddba168573808d36dc8e"
  //          "f2d54d3399c9bcd3ac3482a5ffaeddfe68e9a805375f626b4f2f8cf530c2d95a" ++
  //          "5b3bb54e6e8db52083a9b674e578c843a87c292f0383ddba168573808d36dc8e"
  ).hexToBytes()) |

  for(rlp <- rCh; @msg <- bufCh; @pk <- pubCh; @sig <- sigCh) {
    rlp!(msg, *trace, *itemsCh) |
    for(@[nonce, gasPrice, gasLimit, to, value, data, v, r, s] <- itemsCh) {
      trace!({"tx": [nonce, gasPrice, gasLimit, to, value, data, v, r, s]}) |
      new hashCh, verifyCh in {
        // msg is 139 bytes long
        // "19".hexToBytes() ++ "Ethereum Signed Message:\n139".toUtf8Bytes() ++
        // @"keccak256Hash"!(msg, *hashCh) |

        // > tx.hash(false).toString('hex')
        // or, equivalently:
        // const zb = Buffer.from([])
        // > ethUtil.rlphash([tx.nonce, tx.gasPrice, tx.gasLimit, tx.to, tx.value, tx.data, ethUtil.toBuffer(tx._chainId), zb, zb])
        hashCh!("df2a7cb6d05278504959987a144c116dbd11cbdc50d6482c5bae84a7f41e2113".hexToBytes()) |

        for(@hash <- hashCh) {
          trace!({"hash": hash}) |

          trace!({"verifying sig": sig, "over": hash, "pubKey": pk}) |
          @"secp256k1Verify"!(hash, sig, pk, *verifyCh) |
          for (@ok <- verifyCh) {
            trace!({"sig ok?": ok})
          }
        }
      }
    }
  }
}
