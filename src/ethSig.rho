new trace(`rho:io:stderr`), rl(`rho:registry:lookup`),
verifySignature, pkDER, sigDER, rlpCh in {
  rl!(`rho:id:epm7u46j9h7yzqsrx7kffyaxotcc1ma76z4om7ui8hiewdpjdotakh`, *rlpCh) |
  for(rlp <- rlpCh) {

    // Verify Signature of rlp-encoded Ethereum Transaction
    // ref https://github.com/ethereumjs/ethereumjs-tx/blob/master/docs/index.md#verifysignature
    contract verifySignature(
      @{msg /\ ByteArray},
      // ISSUE: the public key can be recovered from the signature, but
      // rholang doesn't expose `ecrecover` (yet?)
      // so we have the caller supply the pk.
      @{pk /\ ByteArray},
      // ISSUE: we have rlp decoding, but until we have rlp encoding,
      // we have the caller supply the tx hash.
      @{hash /\ ByteArray},
      return
    ) = {
      // trace!({"msg": msg, "pk": pk}) |
      new itemsCh, sigCh, pubCh, verifyCh in {
        rlp!(msg, *trace, *itemsCh) |
        for(@[nonce, gasPrice, gasLimit, to, value, data, v, r, s] <- itemsCh) {
          // trace!({"tx": [nonce, gasPrice, gasLimit, to, value, data, v, r, s]}) |

          pkDER!(pk, *pubCh) |
          sigDER!(r, s, *sigCh) |

          for(@sig <- sigCh; @pk <- pubCh) {
            trace!({"verifying sig": sig, "over": hash, "pubKey": pk}) |
            @"secp256k1Verify"!(hash, sig, pk, *verifyCh) |
            for (@ok <- verifyCh) {
              // trace!({"sig ok?": ok}) |
              if (ok) {
                return!({"items": [nonce, gasPrice, gasLimit, to, value, data, v, r, s]})
              } else {
                return!({"ok TODO": false}) // ISSUE: find out what ethereumjs-tx returns on failure
              }
            }
          }
        }
      }
    } |

    // ASN1 Distinguished Encoding Rules (DER) for public key
    contract pkDER(@{pk /\ ByteArray}, return) = {
      // trace!({"pkDER": pk}) |
      return!("${OctetString}${pk}".toUtf8Bytes() %% { "OctetString": 4, "pk": pk })
    } |

    // ASN1 Distinguished Encoding Rules (DER) for signature
    // i.e. SEQUENCE { r INTEGER, S INTEGER }
    contract sigDER(@{r /\ ByteArray}, @{s /\ ByteArray}, return) = {
      // trace!({"sigDERr": r, "s": s}) |
      new zpad, rpCh, spCh in {
        zpad!(r, *rpCh) | zpad!(s, *spCh) |
        for(@rp <- rpCh; @sp <- spCh) {
          return!("${SEQUENCE}${lenRS}${INTEGER}${lenR}${r}${INTEGER}${lenS}${s}".toUtf8Bytes() %% {
            "SEQUENCE": 48,  // 0x20 + tag 0x10
            "lenRS": 2 + 1 + rp.length() + 1 + sp.length(),
            "INTEGER": 2,
            "r": rp, "lenR": rp.length(),
            "s": sp, "lenS": sp.length()
          })
        } |
        contract zpad(@{bn /\ ByteArray}, return) = {
          // trace!({"zpad": bn.nth(0)}) |
          if (bn.nth(0) >= 128) {
            return!("00".hexToBytes() ++ bn)
          } else {
            return!(bn)
          }
        }
      }
    } |

    new resultCh in {
      trace!("ethereumjs-tx README test case") |

      verifySignature!(
        // tx.serialize().toString('hex')
        "f889808609184e72a00082271094000000000000000000000000000000000000000080a47f746573743200000000000000000000000000000000000000000000000000000060005729a0f2d54d3399c9bcd3ac3482a5ffaeddfe68e9a805375f626b4f2f8cf530c2d95aa05b3bb54e6e8db52083a9b674e578c843a87c292f0383ddba168573808d36dc8e".hexToBytes(),
        // > tx.getSenderPublicKey().toString('hex')
        ("6d9038945ff8f4669201ba1e806c9a46a5034a578e4d52c03152198538039294" ++
          "4efd6c702504d9130573bb939f5c124af95d38168546cc7207a7e0baf14172ff").hexToBytes(),

        // msg is 139 bytes long
        // "19".hexToBytes() ++ "Ethereum Signed Message:\n139".toUtf8Bytes() ++
        // @"keccak256Hash"!(msg, *hashCh) |

        // > tx.hash(false).toString('hex')
        // or, equivalently:
        // const zb = Buffer.from([])
        // > ethUtil.rlphash([tx.nonce, tx.gasPrice, tx.gasLimit, tx.to, tx.value, tx.data, ethUtil.toBuffer(tx._chainId), zb, zb])
        "df2a7cb6d05278504959987a144c116dbd11cbdc50d6482c5bae84a7f41e2113".hexToBytes(),
        *resultCh) |

      for(@actual <- resultCh) {
        trace!({"actual from README": actual})
      }
    } |

    new resultCh in {
      verifySignature!(
        // https://github.com/ethereumjs/ethereumjs-tx/blob/master/test/txs.json#L22-L32
        "f86d068609184e72a0008201f494be862ad9abfe6f22bcb087716c7d89a26051f74c88016345785d8a0000801ca024a484bfa7380860e9fa0a9f5e4b64b985e860ca31abd36e66583f9030c2e29da04d5ef07d9e73fa2fbfdad059591b4f13d0aa79e7634a2bb00174c9200cabb04d".hexToBytes(),
        "eca8b8b663b31277cfa6023bc1f4cddd4b5e5f9625c966634b2e499cae52437754536931a0b5dbbb58c62e84440c3c32db4d04a1f4fb1c6ac0bd2d9ad50028a1".hexToBytes(),
        "073c878297a789a52ba1fb9c0c761114e9a0267c0d9ea496aa06fcac5db421e9".hexToBytes(),
        *resultCh) |

      for(@actual <- resultCh) {
        trace!({"actual test2": actual})
      }
    }
  }
}
